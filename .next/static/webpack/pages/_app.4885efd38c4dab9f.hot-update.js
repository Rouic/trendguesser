"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "(pages-dir-browser)/./src/lib/firebase/trendGuesserService.ts":
/*!*************************************************!*\
  !*** ./src/lib/firebase/trendGuesserService.ts ***!
  \*************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TrendGuesserService: () => (/* binding */ TrendGuesserService)\n/* harmony export */ });\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/firestore */ \"(pages-dir-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./firebase */ \"(pages-dir-browser)/./src/lib/firebase/firebase.ts\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uuid */ \"(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/index.js\");\n/* harmony import */ var _mockData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mockData */ \"(pages-dir-browser)/./src/lib/firebase/mockData.ts\");\n// src/lib/firebase/trendGuesserService.ts\n\n\n\n\n// Development mode flag\nconst USE_MOCK_DATA =  true || 0;\nclass TrendGuesserService {\n    // Start a new game with selected category\n    static async startGame(gameId, category, customTerm) {\n        try {\n            // In mock mode, we don't need to check if the game exists\n            if (!USE_MOCK_DATA) {\n                const gameRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'games', gameId.toUpperCase());\n                const gameDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(gameRef);\n                if (!gameDoc.exists()) {\n                    throw new Error('Game does not exist');\n                }\n            } else {\n                console.log('Using mock data for game start');\n            }\n            // Get terms for the selected category\n            let terms = [];\n            if (category === 'custom' && customTerm) {\n                // For custom games, fetch the custom term and related terms\n                terms = await this.fetchCustomTermWithRelated(customTerm);\n            } else {\n                // For predefined categories, fetch terms from the database\n                terms = await this.fetchTermsByCategory(category);\n            }\n            if (terms.length < 2) {\n                throw new Error('Not enough terms available');\n            }\n            // Shuffle the terms\n            const shuffledTerms = this.shuffleTerms(terms);\n            // Initialize game state with first two terms\n            const gameState = {\n                currentRound: 1,\n                knownTerm: shuffledTerms[0],\n                hiddenTerm: shuffledTerms[1],\n                category,\n                started: true,\n                finished: false,\n                usedTerms: [\n                    shuffledTerms[0].id,\n                    shuffledTerms[1].id\n                ],\n                terms: shuffledTerms.slice(2),\n                customTerm: category === 'custom' ? customTerm : undefined\n            };\n            if (!USE_MOCK_DATA) {\n                // Update the game document with new game state\n                const gameRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'games', gameId.toUpperCase());\n                await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(gameRef, {\n                    status: 'active',\n                    '__trendguesser.state': gameState\n                });\n            } else {\n                // In mock mode, we just log what would have happened\n                console.log('Mock: Game started with category:', category);\n                // Store the game state in sessionStorage for mock mode\n                if (true) {\n                    sessionStorage.setItem(\"game_\".concat(gameId), JSON.stringify({\n                        status: 'active',\n                        '__trendguesser.state': gameState,\n                        [sessionStorage.getItem('mock_user_uid') || 'mock_user']: {\n                            uid: sessionStorage.getItem('mock_user_uid') || 'mock_user',\n                            name: 'Mock Player',\n                            score: 0\n                        }\n                    }));\n                }\n            }\n        } catch (error) {\n            console.error('Error starting game:', error);\n            if (USE_MOCK_DATA) {\n                console.log('Falling back to mock game state due to error');\n                // Create a basic mock game state\n                return;\n            }\n            throw error;\n        }\n    }\n    // Make a guess (higher or lower)\n    static async makeGuess(gameId, playerUid, isHigher) {\n        try {\n            const gameRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'games', gameId.toUpperCase());\n            const gameDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(gameRef);\n            if (!gameDoc.exists()) {\n                throw new Error('Game does not exist');\n            }\n            const gameData = gameDoc.data();\n            const gameState = gameData['__trendguesser.state'];\n            const player = gameData[playerUid];\n            if (!gameState || !gameState.started || gameState.finished) {\n                throw new Error('Game is not active');\n            }\n            // Check if the guess is correct\n            const isCorrect = isHigher ? gameState.hiddenTerm.volume > gameState.knownTerm.volume : gameState.hiddenTerm.volume < gameState.knownTerm.volume;\n            if (isCorrect) {\n                // Correct guess - prepare next round\n                const nextRound = gameState.currentRound + 1;\n                const newPlayerScore = (player.score || 0) + 1;\n                // Update player score\n                await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(gameRef, {\n                    [\"\".concat(playerUid, \".score\")]: newPlayerScore\n                });\n                // If we have more terms, set up next round\n                if (gameState.terms.length > 0) {\n                    const nextTerm = gameState.terms[0];\n                    const remainingTerms = gameState.terms.slice(1);\n                    const updatedState = {\n                        ...gameState,\n                        currentRound: nextRound,\n                        knownTerm: gameState.hiddenTerm,\n                        hiddenTerm: nextTerm,\n                        usedTerms: [\n                            ...gameState.usedTerms,\n                            nextTerm.id\n                        ],\n                        terms: remainingTerms\n                    };\n                    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(gameRef, {\n                        '__trendguesser.state': updatedState\n                    });\n                } else {\n                    // No more terms - player wins by completing all terms\n                    const updatedState = {\n                        ...gameState,\n                        finished: true,\n                        winner: playerUid\n                    };\n                    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(gameRef, {\n                        '__trendguesser.state': updatedState,\n                        status: 'finished'\n                    });\n                    // Update high score if needed\n                    await this.updateHighScore(playerUid, gameState.category, newPlayerScore);\n                }\n                return true;\n            } else {\n                // Incorrect guess - game over\n                const updatedState = {\n                    ...gameState,\n                    finished: true\n                };\n                await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(gameRef, {\n                    '__trendguesser.state': updatedState,\n                    status: 'finished'\n                });\n                // Update high score if needed\n                await this.updateHighScore(playerUid, gameState.category, player.score || 0);\n                return false;\n            }\n        } catch (error) {\n            console.error('Error making guess:', error);\n            throw error;\n        }\n    }\n    // End the game and update high scores\n    static async endGame(gameId, playerUid, finalScore) {\n        try {\n            const gameRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'games', gameId.toUpperCase());\n            const gameDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(gameRef);\n            if (!gameDoc.exists()) {\n                throw new Error('Game does not exist');\n            }\n            const gameData = gameDoc.data();\n            const gameState = gameData['__trendguesser.state'];\n            if (!gameState) {\n                throw new Error('No game state found');\n            }\n            // Only update if game was actually started\n            if (gameState.started) {\n                // Mark game as finished\n                await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(gameRef, {\n                    status: 'finished',\n                    '__trendguesser.state': {\n                        ...gameState,\n                        finished: true\n                    }\n                });\n                // Update high score if needed\n                await this.updateHighScore(playerUid, gameState.category, finalScore);\n            }\n        } catch (error) {\n            console.error('Error ending game:', error);\n            throw error;\n        }\n    }\n    // Create a new game session\n    static async createGame(createdBy, playerName) {\n        try {\n            // Generate a short 6-character game ID (uppercase)\n            const gameId = this.generateGameId();\n            if (USE_MOCK_DATA) {\n                console.log('Using mock data for game creation');\n                // Return the game ID without actually writing to Firestore\n                return gameId;\n            }\n            const gameRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'games', gameId);\n            // Initialize player data\n            const playerData = {\n                uid: createdBy,\n                name: playerName || 'Player',\n                score: 0\n            };\n            // Initial game data\n            const gameData = {\n                id: gameId,\n                createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n                createdBy,\n                gameType: 'trendguesser',\n                status: 'waiting',\n                [createdBy]: playerData\n            };\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setDoc)(gameRef, gameData);\n            return gameId;\n        } catch (error) {\n            console.error('Error creating game:', error);\n            if (USE_MOCK_DATA) {\n                console.log('Falling back to mock data due to error');\n                return this.generateGameId();\n            }\n            throw error;\n        }\n    }\n    // Fetch leaderboard for a category\n    static async getLeaderboard(category) {\n        try {\n            if (USE_MOCK_DATA) {\n                console.log('Using mock data for leaderboard');\n                // Sort and filter the mock leaderboard based on the requested category\n                return _mockData__WEBPACK_IMPORTED_MODULE_2__.sampleLeaderboard.filter((player)=>player.highScores && player.highScores[category]).sort((a, b)=>{\n                    var _a_highScores, _b_highScores;\n                    const scoreA = ((_a_highScores = a.highScores) === null || _a_highScores === void 0 ? void 0 : _a_highScores[category]) || 0;\n                    const scoreB = ((_b_highScores = b.highScores) === null || _b_highScores === void 0 ? void 0 : _b_highScores[category]) || 0;\n                    return scoreB - scoreA;\n                }).slice(0, 10);\n            }\n            const leaderboardRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'leaderboard');\n            const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(leaderboardRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('category', '==', category), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)('score', 'desc'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.limit)(10));\n            const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n            const leaderboard = [];\n            querySnapshot.forEach((doc)=>{\n                const data = doc.data();\n                leaderboard.push({\n                    uid: data.uid,\n                    name: data.name,\n                    score: data.score,\n                    highScores: data.highScores\n                });\n            });\n            return leaderboard;\n        } catch (error) {\n            console.error('Error fetching leaderboard:', error);\n            if (USE_MOCK_DATA) {\n                console.log('Falling back to mock data due to error');\n                return _mockData__WEBPACK_IMPORTED_MODULE_2__.sampleLeaderboard.slice(0, 10);\n            }\n            throw error;\n        }\n    }\n    // Helper methods\n    static async updateHighScore(playerUid, category, score) {\n        try {\n            const playerRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'players', playerUid);\n            const playerDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(playerRef);\n            if (playerDoc.exists()) {\n                var _playerData_highScores;\n                const playerData = playerDoc.data();\n                const currentHighScore = ((_playerData_highScores = playerData.highScores) === null || _playerData_highScores === void 0 ? void 0 : _playerData_highScores[category]) || 0;\n                if (score > currentHighScore) {\n                    // Update player's high score for this category\n                    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(playerRef, {\n                        [\"highScores.\".concat(category)]: score\n                    });\n                    // Also update leaderboard if score is significant\n                    if (score > 5) {\n                        const leaderboardRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'leaderboard', \"\".concat(category, \"_\").concat(playerUid));\n                        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setDoc)(leaderboardRef, {\n                            uid: playerUid,\n                            name: playerData.name || 'Unknown Player',\n                            score,\n                            category,\n                            updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)()\n                        }, {\n                            merge: true\n                        });\n                    }\n                }\n            }\n        } catch (error) {\n            console.error('Error updating high score:', error);\n        // Don't throw, just log - this is a non-critical operation\n        }\n    }\n    static async fetchTermsByCategory(category) {\n        try {\n            if (USE_MOCK_DATA) {\n                console.log('Using mock data for search terms');\n                if (category === 'everything') {\n                    // Return all sample terms\n                    return _mockData__WEBPACK_IMPORTED_MODULE_2__.sampleSearchTerms;\n                } else if (category === 'latest') {\n                    // Return terms sorted by timestamp\n                    return [\n                        ..._mockData__WEBPACK_IMPORTED_MODULE_2__.sampleSearchTerms\n                    ].sort(()=>Math.random() - 0.5);\n                } else {\n                    // Filter by category\n                    const filteredTerms = _mockData__WEBPACK_IMPORTED_MODULE_2__.sampleSearchTerms.filter((term)=>term.category === category);\n                    return filteredTerms.length > 0 ? filteredTerms : _mockData__WEBPACK_IMPORTED_MODULE_2__.sampleSearchTerms;\n                }\n            }\n            const termsRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'searchTerms');\n            let q;\n            if (category === 'everything') {\n                // For \"everything\" category, get a mix of all categories\n                q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(termsRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.limit)(50));\n            } else if (category === 'latest') {\n                // For \"latest\", get the most recently added terms\n                q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(termsRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)('timestamp', 'desc'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.limit)(50));\n            } else {\n                // For specific categories\n                q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(termsRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('category', '==', category), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.limit)(50));\n            }\n            const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n            const terms = [];\n            querySnapshot.forEach((doc)=>{\n                const data = doc.data();\n                terms.push({\n                    ...data,\n                    id: doc.id\n                });\n            });\n            return terms;\n        } catch (error) {\n            console.error('Error fetching terms:', error);\n            if (USE_MOCK_DATA) {\n                console.log('Falling back to mock data due to error');\n                return _mockData__WEBPACK_IMPORTED_MODULE_2__.sampleSearchTerms;\n            }\n            throw error;\n        }\n    }\n    static async fetchCustomTermWithRelated(customTerm) {\n        try {\n            // This would typically call a Firebase Function to get the custom term data\n            // For now, we'll simulate it with a placeholder\n            // First term will be the custom one\n            const customSearchTerm = {\n                id: (0,uuid__WEBPACK_IMPORTED_MODULE_3__.v4)(),\n                term: customTerm,\n                volume: Math.floor(Math.random() * 100) + 1,\n                category: 'custom',\n                imageUrl: \"https://source.unsplash.com/featured/?\".concat(encodeURIComponent(customTerm)),\n                timestamp: firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.Timestamp.now()\n            };\n            // Then get some related terms from the database (random for now)\n            const termsRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'searchTerms');\n            const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(termsRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.limit)(20));\n            const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n            const terms = [\n                customSearchTerm\n            ];\n            querySnapshot.forEach((doc)=>{\n                const data = doc.data();\n                terms.push({\n                    ...data,\n                    id: doc.id\n                });\n            });\n            return terms;\n        } catch (error) {\n            console.error('Error fetching custom term:', error);\n            throw error;\n        }\n    }\n    static shuffleTerms(terms) {\n        const shuffled = [\n            ...terms\n        ];\n        for(let i = shuffled.length - 1; i > 0; i--){\n            const j = Math.floor(Math.random() * (i + 1));\n            [shuffled[i], shuffled[j]] = [\n                shuffled[j],\n                shuffled[i]\n            ];\n        }\n        return shuffled;\n    }\n    static generateGameId() {\n        // Generate a 6-character alphanumeric code (uppercase)\n        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Removed confusable characters\n        let result = '';\n        for(let i = 0; i < 6; i++){\n            result += chars.charAt(Math.floor(Math.random() * chars.length));\n        }\n        return result;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9saWIvZmlyZWJhc2UvdHJlbmRHdWVzc2VyU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLDBDQUEwQztBQWdCZDtBQUNJO0FBQ0k7QUFFOEI7QUFFbEUsd0JBQXdCO0FBQ3hCLE1BQU1pQixnQkFBZ0JDLEtBQWdELElBQy9DQSxDQUFzQztBQUV0RCxNQUFNRztJQUNYLDBDQUEwQztJQUMxQyxhQUFhQyxVQUFVQyxNQUFjLEVBQUVDLFFBQXdCLEVBQUVDLFVBQW1CLEVBQWlCO1FBQ25HLElBQUk7WUFDRiwwREFBMEQ7WUFDMUQsSUFBSSxDQUFDUixlQUFlO2dCQUNsQixNQUFNUyxVQUFVMUIsdURBQUdBLENBQUNZLHlDQUFFQSxFQUFFLFNBQVNXLE9BQU9JLFdBQVc7Z0JBQ25ELE1BQU1DLFVBQVUsTUFBTXpCLDBEQUFNQSxDQUFDdUI7Z0JBRTdCLElBQUksQ0FBQ0UsUUFBUUMsTUFBTSxJQUFJO29CQUNyQixNQUFNLElBQUlDLE1BQU07Z0JBQ2xCO1lBQ0YsT0FBTztnQkFDTEMsUUFBUUMsR0FBRyxDQUFDO1lBQ2Q7WUFFQSxzQ0FBc0M7WUFDdEMsSUFBSUMsUUFBc0IsRUFBRTtZQUU1QixJQUFJVCxhQUFhLFlBQVlDLFlBQVk7Z0JBQ3ZDLDREQUE0RDtnQkFDNURRLFFBQVEsTUFBTSxJQUFJLENBQUNDLDBCQUEwQixDQUFDVDtZQUNoRCxPQUFPO2dCQUNMLDJEQUEyRDtnQkFDM0RRLFFBQVEsTUFBTSxJQUFJLENBQUNFLG9CQUFvQixDQUFDWDtZQUMxQztZQUVBLElBQUlTLE1BQU1HLE1BQU0sR0FBRyxHQUFHO2dCQUNwQixNQUFNLElBQUlOLE1BQU07WUFDbEI7WUFFQSxvQkFBb0I7WUFDcEIsTUFBTU8sZ0JBQWdCLElBQUksQ0FBQ0MsWUFBWSxDQUFDTDtZQUV4Qyw2Q0FBNkM7WUFDN0MsTUFBTU0sWUFBbUM7Z0JBQ3ZDQyxjQUFjO2dCQUNkQyxXQUFXSixhQUFhLENBQUMsRUFBRTtnQkFDM0JL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Q0FBQ04sS0FBS0MsTUFBTSxLQUFLYSxNQUFNaEYsTUFBTTtRQUNoRTtRQUNBLE9BQU9pRjtJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGV4L0RldmVsb3Blci90cmVuZGd1ZXNzZXIvc3JjL2xpYi9maXJlYmFzZS90cmVuZEd1ZXNzZXJTZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9saWIvZmlyZWJhc2UvdHJlbmRHdWVzc2VyU2VydmljZS50c1xuaW1wb3J0IHsgXG4gIGRvYywgXG4gIHNldERvYywgXG4gIHVwZGF0ZURvYywgXG4gIGdldERvYywgXG4gIGNvbGxlY3Rpb24sIFxuICBxdWVyeSwgXG4gIHdoZXJlLCBcbiAgZ2V0RG9jcywgXG4gIGFycmF5VW5pb24sIFxuICBUaW1lc3RhbXAsIFxuICBzZXJ2ZXJUaW1lc3RhbXAsXG4gIGluY3JlbWVudCxcbiAgbGltaXQsXG4gIG9yZGVyQnlcbn0gZnJvbSAnZmlyZWJhc2UvZmlyZXN0b3JlJztcbmltcG9ydCB7IGRiIH0gZnJvbSAnLi9maXJlYmFzZSc7XG5pbXBvcnQgeyB2NCBhcyB1dWlkdjQgfSBmcm9tICd1dWlkJztcbmltcG9ydCB7IFNlYXJjaENhdGVnb3J5LCBTZWFyY2hUZXJtLCBUcmVuZEd1ZXNzZXJHYW1lU3RhdGUsIFRyZW5kR3Vlc3NlclBsYXllciB9IGZyb20gJ0AvdHlwZXMnO1xuaW1wb3J0IHsgc2FtcGxlU2VhcmNoVGVybXMsIHNhbXBsZUxlYWRlcmJvYXJkIH0gZnJvbSAnLi9tb2NrRGF0YSc7XG5cbi8vIERldmVsb3BtZW50IG1vZGUgZmxhZ1xuY29uc3QgVVNFX01PQ0tfREFUQSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1VTRV9NT0NLX0RBVEEgPT09ICd0cnVlJyB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCc7XG5cbmV4cG9ydCBjbGFzcyBUcmVuZEd1ZXNzZXJTZXJ2aWNlIHtcbiAgLy8gU3RhcnQgYSBuZXcgZ2FtZSB3aXRoIHNlbGVjdGVkIGNhdGVnb3J5XG4gIHN0YXRpYyBhc3luYyBzdGFydEdhbWUoZ2FtZUlkOiBzdHJpbmcsIGNhdGVnb3J5OiBTZWFyY2hDYXRlZ29yeSwgY3VzdG9tVGVybT86IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBJbiBtb2NrIG1vZGUsIHdlIGRvbid0IG5lZWQgdG8gY2hlY2sgaWYgdGhlIGdhbWUgZXhpc3RzXG4gICAgICBpZiAoIVVTRV9NT0NLX0RBVEEpIHtcbiAgICAgICAgY29uc3QgZ2FtZVJlZiA9IGRvYyhkYiwgJ2dhbWVzJywgZ2FtZUlkLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICBjb25zdCBnYW1lRG9jID0gYXdhaXQgZ2V0RG9jKGdhbWVSZWYpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFnYW1lRG9jLmV4aXN0cygpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHYW1lIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdVc2luZyBtb2NrIGRhdGEgZm9yIGdhbWUgc3RhcnQnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gR2V0IHRlcm1zIGZvciB0aGUgc2VsZWN0ZWQgY2F0ZWdvcnlcbiAgICAgIGxldCB0ZXJtczogU2VhcmNoVGVybVtdID0gW107XG4gICAgICBcbiAgICAgIGlmIChjYXRlZ29yeSA9PT0gJ2N1c3RvbScgJiYgY3VzdG9tVGVybSkge1xuICAgICAgICAvLyBGb3IgY3VzdG9tIGdhbWVzLCBmZXRjaCB0aGUgY3VzdG9tIHRlcm0gYW5kIHJlbGF0ZWQgdGVybXNcbiAgICAgICAgdGVybXMgPSBhd2FpdCB0aGlzLmZldGNoQ3VzdG9tVGVybVdpdGhSZWxhdGVkKGN1c3RvbVRlcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIHByZWRlZmluZWQgY2F0ZWdvcmllcywgZmV0Y2ggdGVybXMgZnJvbSB0aGUgZGF0YWJhc2VcbiAgICAgICAgdGVybXMgPSBhd2FpdCB0aGlzLmZldGNoVGVybXNCeUNhdGVnb3J5KGNhdGVnb3J5KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHRlcm1zLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgZW5vdWdoIHRlcm1zIGF2YWlsYWJsZScpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTaHVmZmxlIHRoZSB0ZXJtc1xuICAgICAgY29uc3Qgc2h1ZmZsZWRUZXJtcyA9IHRoaXMuc2h1ZmZsZVRlcm1zKHRlcm1zKTtcbiAgICAgIFxuICAgICAgLy8gSW5pdGlhbGl6ZSBnYW1lIHN0YXRlIHdpdGggZmlyc3QgdHdvIHRlcm1zXG4gICAgICBjb25zdCBnYW1lU3RhdGU6IFRyZW5kR3Vlc3NlckdhbWVTdGF0ZSA9IHtcbiAgICAgICAgY3VycmVudFJvdW5kOiAxLFxuICAgICAgICBrbm93blRlcm06IHNodWZmbGVkVGVybXNbMF0sXG4gICAgICAgIGhpZGRlblRlcm06IHNodWZmbGVkVGVybXNbMV0sXG4gICAgICAgIGNhdGVnb3J5LFxuICAgICAgICBzdGFydGVkOiB0cnVlLFxuICAgICAgICBmaW5pc2hlZDogZmFsc2UsXG4gICAgICAgIHVzZWRUZXJtczogW3NodWZmbGVkVGVybXNbMF0uaWQsIHNodWZmbGVkVGVybXNbMV0uaWRdLFxuICAgICAgICB0ZXJtczogc2h1ZmZsZWRUZXJtcy5zbGljZSgyKSwgLy8gU3RvcmUgcmVtYWluaW5nIHRlcm1zXG4gICAgICAgIGN1c3RvbVRlcm06IGNhdGVnb3J5ID09PSAnY3VzdG9tJyA/IGN1c3RvbVRlcm0gOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGlmICghVVNFX01PQ0tfREFUQSkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGdhbWUgZG9jdW1lbnQgd2l0aCBuZXcgZ2FtZSBzdGF0ZVxuICAgICAgICBjb25zdCBnYW1lUmVmID0gZG9jKGRiLCAnZ2FtZXMnLCBnYW1lSWQudG9VcHBlckNhc2UoKSk7XG4gICAgICAgIGF3YWl0IHVwZGF0ZURvYyhnYW1lUmVmLCB7XG4gICAgICAgICAgc3RhdHVzOiAnYWN0aXZlJyxcbiAgICAgICAgICAnX190cmVuZGd1ZXNzZXIuc3RhdGUnOiBnYW1lU3RhdGVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJbiBtb2NrIG1vZGUsIHdlIGp1c3QgbG9nIHdoYXQgd291bGQgaGF2ZSBoYXBwZW5lZFxuICAgICAgICBjb25zb2xlLmxvZygnTW9jazogR2FtZSBzdGFydGVkIHdpdGggY2F0ZWdvcnk6JywgY2F0ZWdvcnkpO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RvcmUgdGhlIGdhbWUgc3RhdGUgaW4gc2Vzc2lvblN0b3JhZ2UgZm9yIG1vY2sgbW9kZVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKGBnYW1lXyR7Z2FtZUlkfWAsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgICAgICAnX190cmVuZGd1ZXNzZXIuc3RhdGUnOiBnYW1lU3RhdGUsXG4gICAgICAgICAgICBbc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnbW9ja191c2VyX3VpZCcpIHx8ICdtb2NrX3VzZXInXToge1xuICAgICAgICAgICAgICB1aWQ6IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ21vY2tfdXNlcl91aWQnKSB8fCAnbW9ja191c2VyJyxcbiAgICAgICAgICAgICAgbmFtZTogJ01vY2sgUGxheWVyJyxcbiAgICAgICAgICAgICAgc2NvcmU6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzdGFydGluZyBnYW1lOicsIGVycm9yKTtcbiAgICAgIFxuICAgICAgaWYgKFVTRV9NT0NLX0RBVEEpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0ZhbGxpbmcgYmFjayB0byBtb2NrIGdhbWUgc3RhdGUgZHVlIHRvIGVycm9yJyk7XG4gICAgICAgIC8vIENyZWF0ZSBhIGJhc2ljIG1vY2sgZ2FtZSBzdGF0ZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gTWFrZSBhIGd1ZXNzIChoaWdoZXIgb3IgbG93ZXIpXG4gIHN0YXRpYyBhc3luYyBtYWtlR3Vlc3MoZ2FtZUlkOiBzdHJpbmcsIHBsYXllclVpZDogc3RyaW5nLCBpc0hpZ2hlcjogYm9vbGVhbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBnYW1lUmVmID0gZG9jKGRiLCAnZ2FtZXMnLCBnYW1lSWQudG9VcHBlckNhc2UoKSk7XG4gICAgICBjb25zdCBnYW1lRG9jID0gYXdhaXQgZ2V0RG9jKGdhbWVSZWYpO1xuICAgICAgXG4gICAgICBpZiAoIWdhbWVEb2MuZXhpc3RzKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHYW1lIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGdhbWVEYXRhID0gZ2FtZURvYy5kYXRhKCk7XG4gICAgICBjb25zdCBnYW1lU3RhdGUgPSBnYW1lRGF0YVsnX190cmVuZGd1ZXNzZXIuc3RhdGUnXSBhcyBUcmVuZEd1ZXNzZXJHYW1lU3RhdGU7XG4gICAgICBjb25zdCBwbGF5ZXIgPSBnYW1lRGF0YVtwbGF5ZXJVaWRdIGFzIFRyZW5kR3Vlc3NlclBsYXllcjtcbiAgICAgIFxuICAgICAgaWYgKCFnYW1lU3RhdGUgfHwgIWdhbWVTdGF0ZS5zdGFydGVkIHx8IGdhbWVTdGF0ZS5maW5pc2hlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dhbWUgaXMgbm90IGFjdGl2ZScpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0aGUgZ3Vlc3MgaXMgY29ycmVjdFxuICAgICAgY29uc3QgaXNDb3JyZWN0ID0gaXNIaWdoZXIgXG4gICAgICAgID8gZ2FtZVN0YXRlLmhpZGRlblRlcm0udm9sdW1lID4gZ2FtZVN0YXRlLmtub3duVGVybS52b2x1bWVcbiAgICAgICAgOiBnYW1lU3RhdGUuaGlkZGVuVGVybS52b2x1bWUgPCBnYW1lU3RhdGUua25vd25UZXJtLnZvbHVtZTtcbiAgICAgIFxuICAgICAgaWYgKGlzQ29ycmVjdCkge1xuICAgICAgICAvLyBDb3JyZWN0IGd1ZXNzIC0gcHJlcGFyZSBuZXh0IHJvdW5kXG4gICAgICAgIGNvbnN0IG5leHRSb3VuZCA9IGdhbWVTdGF0ZS5jdXJyZW50Um91bmQgKyAxO1xuICAgICAgICBjb25zdCBuZXdQbGF5ZXJTY29yZSA9IChwbGF5ZXIuc2NvcmUgfHwgMCkgKyAxO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHBsYXllciBzY29yZVxuICAgICAgICBhd2FpdCB1cGRhdGVEb2MoZ2FtZVJlZiwge1xuICAgICAgICAgIFtgJHtwbGF5ZXJVaWR9LnNjb3JlYF06IG5ld1BsYXllclNjb3JlXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBtb3JlIHRlcm1zLCBzZXQgdXAgbmV4dCByb3VuZFxuICAgICAgICBpZiAoZ2FtZVN0YXRlLnRlcm1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBuZXh0VGVybSA9IGdhbWVTdGF0ZS50ZXJtc1swXTtcbiAgICAgICAgICBjb25zdCByZW1haW5pbmdUZXJtcyA9IGdhbWVTdGF0ZS50ZXJtcy5zbGljZSgxKTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCB1cGRhdGVkU3RhdGU6IFRyZW5kR3Vlc3NlckdhbWVTdGF0ZSA9IHtcbiAgICAgICAgICAgIC4uLmdhbWVTdGF0ZSxcbiAgICAgICAgICAgIGN1cnJlbnRSb3VuZDogbmV4dFJvdW5kLFxuICAgICAgICAgICAga25vd25UZXJtOiBnYW1lU3RhdGUuaGlkZGVuVGVybSxcbiAgICAgICAgICAgIGhpZGRlblRlcm06IG5leHRUZXJtLFxuICAgICAgICAgICAgdXNlZFRlcm1zOiBbLi4uZ2FtZVN0YXRlLnVzZWRUZXJtcywgbmV4dFRlcm0uaWRdLFxuICAgICAgICAgICAgdGVybXM6IHJlbWFpbmluZ1Rlcm1zXG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICBhd2FpdCB1cGRhdGVEb2MoZ2FtZVJlZiwge1xuICAgICAgICAgICAgJ19fdHJlbmRndWVzc2VyLnN0YXRlJzogdXBkYXRlZFN0YXRlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gbW9yZSB0ZXJtcyAtIHBsYXllciB3aW5zIGJ5IGNvbXBsZXRpbmcgYWxsIHRlcm1zXG4gICAgICAgICAgY29uc3QgdXBkYXRlZFN0YXRlOiBUcmVuZEd1ZXNzZXJHYW1lU3RhdGUgPSB7XG4gICAgICAgICAgICAuLi5nYW1lU3RhdGUsXG4gICAgICAgICAgICBmaW5pc2hlZDogdHJ1ZSxcbiAgICAgICAgICAgIHdpbm5lcjogcGxheWVyVWlkXG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICBhd2FpdCB1cGRhdGVEb2MoZ2FtZVJlZiwge1xuICAgICAgICAgICAgJ19fdHJlbmRndWVzc2VyLnN0YXRlJzogdXBkYXRlZFN0YXRlLFxuICAgICAgICAgICAgc3RhdHVzOiAnZmluaXNoZWQnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVXBkYXRlIGhpZ2ggc2NvcmUgaWYgbmVlZGVkXG4gICAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVIaWdoU2NvcmUocGxheWVyVWlkLCBnYW1lU3RhdGUuY2F0ZWdvcnksIG5ld1BsYXllclNjb3JlKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJbmNvcnJlY3QgZ3Vlc3MgLSBnYW1lIG92ZXJcbiAgICAgICAgY29uc3QgdXBkYXRlZFN0YXRlOiBUcmVuZEd1ZXNzZXJHYW1lU3RhdGUgPSB7XG4gICAgICAgICAgLi4uZ2FtZVN0YXRlLFxuICAgICAgICAgIGZpbmlzaGVkOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBhd2FpdCB1cGRhdGVEb2MoZ2FtZVJlZiwge1xuICAgICAgICAgICdfX3RyZW5kZ3Vlc3Nlci5zdGF0ZSc6IHVwZGF0ZWRTdGF0ZSxcbiAgICAgICAgICBzdGF0dXM6ICdmaW5pc2hlZCdcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgaGlnaCBzY29yZSBpZiBuZWVkZWRcbiAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVIaWdoU2NvcmUocGxheWVyVWlkLCBnYW1lU3RhdGUuY2F0ZWdvcnksIHBsYXllci5zY29yZSB8fCAwKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBtYWtpbmcgZ3Vlc3M6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvLyBFbmQgdGhlIGdhbWUgYW5kIHVwZGF0ZSBoaWdoIHNjb3Jlc1xuICBzdGF0aWMgYXN5bmMgZW5kR2FtZShnYW1lSWQ6IHN0cmluZywgcGxheWVyVWlkOiBzdHJpbmcsIGZpbmFsU2NvcmU6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBnYW1lUmVmID0gZG9jKGRiLCAnZ2FtZXMnLCBnYW1lSWQudG9VcHBlckNhc2UoKSk7XG4gICAgICBjb25zdCBnYW1lRG9jID0gYXdhaXQgZ2V0RG9jKGdhbWVSZWYpO1xuICAgICAgXG4gICAgICBpZiAoIWdhbWVEb2MuZXhpc3RzKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHYW1lIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGdhbWVEYXRhID0gZ2FtZURvYy5kYXRhKCk7XG4gICAgICBjb25zdCBnYW1lU3RhdGUgPSBnYW1lRGF0YVsnX190cmVuZGd1ZXNzZXIuc3RhdGUnXSBhcyBUcmVuZEd1ZXNzZXJHYW1lU3RhdGU7XG4gICAgICBcbiAgICAgIGlmICghZ2FtZVN0YXRlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZ2FtZSBzdGF0ZSBmb3VuZCcpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBPbmx5IHVwZGF0ZSBpZiBnYW1lIHdhcyBhY3R1YWxseSBzdGFydGVkXG4gICAgICBpZiAoZ2FtZVN0YXRlLnN0YXJ0ZWQpIHtcbiAgICAgICAgLy8gTWFyayBnYW1lIGFzIGZpbmlzaGVkXG4gICAgICAgIGF3YWl0IHVwZGF0ZURvYyhnYW1lUmVmLCB7XG4gICAgICAgICAgc3RhdHVzOiAnZmluaXNoZWQnLFxuICAgICAgICAgICdfX3RyZW5kZ3Vlc3Nlci5zdGF0ZSc6IHtcbiAgICAgICAgICAgIC4uLmdhbWVTdGF0ZSxcbiAgICAgICAgICAgIGZpbmlzaGVkOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBoaWdoIHNjb3JlIGlmIG5lZWRlZFxuICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZUhpZ2hTY29yZShwbGF5ZXJVaWQsIGdhbWVTdGF0ZS5jYXRlZ29yeSwgZmluYWxTY29yZSk7XG4gICAgICB9XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZW5kaW5nIGdhbWU6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvLyBDcmVhdGUgYSBuZXcgZ2FtZSBzZXNzaW9uXG4gIHN0YXRpYyBhc3luYyBjcmVhdGVHYW1lKGNyZWF0ZWRCeTogc3RyaW5nLCBwbGF5ZXJOYW1lOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBHZW5lcmF0ZSBhIHNob3J0IDYtY2hhcmFjdGVyIGdhbWUgSUQgKHVwcGVyY2FzZSlcbiAgICAgIGNvbnN0IGdhbWVJZCA9IHRoaXMuZ2VuZXJhdGVHYW1lSWQoKTtcbiAgICAgIFxuICAgICAgaWYgKFVTRV9NT0NLX0RBVEEpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1VzaW5nIG1vY2sgZGF0YSBmb3IgZ2FtZSBjcmVhdGlvbicpO1xuICAgICAgICAvLyBSZXR1cm4gdGhlIGdhbWUgSUQgd2l0aG91dCBhY3R1YWxseSB3cml0aW5nIHRvIEZpcmVzdG9yZVxuICAgICAgICByZXR1cm4gZ2FtZUlkO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBnYW1lUmVmID0gZG9jKGRiLCAnZ2FtZXMnLCBnYW1lSWQpO1xuICAgICAgXG4gICAgICAvLyBJbml0aWFsaXplIHBsYXllciBkYXRhXG4gICAgICBjb25zdCBwbGF5ZXJEYXRhOiBUcmVuZEd1ZXNzZXJQbGF5ZXIgPSB7XG4gICAgICAgIHVpZDogY3JlYXRlZEJ5LFxuICAgICAgICBuYW1lOiBwbGF5ZXJOYW1lIHx8ICdQbGF5ZXInLFxuICAgICAgICBzY29yZTogMFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gSW5pdGlhbCBnYW1lIGRhdGFcbiAgICAgIGNvbnN0IGdhbWVEYXRhID0ge1xuICAgICAgICBpZDogZ2FtZUlkLFxuICAgICAgICBjcmVhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpLFxuICAgICAgICBjcmVhdGVkQnksXG4gICAgICAgIGdhbWVUeXBlOiAndHJlbmRndWVzc2VyJyxcbiAgICAgICAgc3RhdHVzOiAnd2FpdGluZycsXG4gICAgICAgIFtjcmVhdGVkQnldOiBwbGF5ZXJEYXRhXG4gICAgICB9O1xuICAgICAgXG4gICAgICBhd2FpdCBzZXREb2MoZ2FtZVJlZiwgZ2FtZURhdGEpO1xuICAgICAgcmV0dXJuIGdhbWVJZDtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBnYW1lOicsIGVycm9yKTtcbiAgICAgIFxuICAgICAgaWYgKFVTRV9NT0NLX0RBVEEpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0ZhbGxpbmcgYmFjayB0byBtb2NrIGRhdGEgZHVlIHRvIGVycm9yJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlR2FtZUlkKCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gRmV0Y2ggbGVhZGVyYm9hcmQgZm9yIGEgY2F0ZWdvcnlcbiAgc3RhdGljIGFzeW5jIGdldExlYWRlcmJvYXJkKGNhdGVnb3J5OiBTZWFyY2hDYXRlZ29yeSk6IFByb21pc2U8VHJlbmRHdWVzc2VyUGxheWVyW10+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKFVTRV9NT0NLX0RBVEEpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1VzaW5nIG1vY2sgZGF0YSBmb3IgbGVhZGVyYm9hcmQnKTtcbiAgICAgICAgLy8gU29ydCBhbmQgZmlsdGVyIHRoZSBtb2NrIGxlYWRlcmJvYXJkIGJhc2VkIG9uIHRoZSByZXF1ZXN0ZWQgY2F0ZWdvcnlcbiAgICAgICAgcmV0dXJuIHNhbXBsZUxlYWRlcmJvYXJkXG4gICAgICAgICAgLmZpbHRlcihwbGF5ZXIgPT4gcGxheWVyLmhpZ2hTY29yZXMgJiYgcGxheWVyLmhpZ2hTY29yZXNbY2F0ZWdvcnldKVxuICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY29yZUEgPSBhLmhpZ2hTY29yZXM/LltjYXRlZ29yeV0gfHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNjb3JlQiA9IGIuaGlnaFNjb3Jlcz8uW2NhdGVnb3J5XSB8fCAwO1xuICAgICAgICAgICAgcmV0dXJuIHNjb3JlQiAtIHNjb3JlQTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5zbGljZSgwLCAxMCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGxlYWRlcmJvYXJkUmVmID0gY29sbGVjdGlvbihkYiwgJ2xlYWRlcmJvYXJkJyk7XG4gICAgICBjb25zdCBxID0gcXVlcnkoXG4gICAgICAgIGxlYWRlcmJvYXJkUmVmLFxuICAgICAgICB3aGVyZSgnY2F0ZWdvcnknLCAnPT0nLCBjYXRlZ29yeSksXG4gICAgICAgIG9yZGVyQnkoJ3Njb3JlJywgJ2Rlc2MnKSxcbiAgICAgICAgbGltaXQoMTApXG4gICAgICApO1xuICAgICAgXG4gICAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhxKTtcbiAgICAgIGNvbnN0IGxlYWRlcmJvYXJkOiBUcmVuZEd1ZXNzZXJQbGF5ZXJbXSA9IFtdO1xuICAgICAgXG4gICAgICBxdWVyeVNuYXBzaG90LmZvckVhY2goKGRvYykgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0gZG9jLmRhdGEoKTtcbiAgICAgICAgbGVhZGVyYm9hcmQucHVzaCh7XG4gICAgICAgICAgdWlkOiBkYXRhLnVpZCxcbiAgICAgICAgICBuYW1lOiBkYXRhLm5hbWUsXG4gICAgICAgICAgc2NvcmU6IGRhdGEuc2NvcmUsXG4gICAgICAgICAgaGlnaFNjb3JlczogZGF0YS5oaWdoU2NvcmVzXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiBsZWFkZXJib2FyZDtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBsZWFkZXJib2FyZDonLCBlcnJvcik7XG4gICAgICBcbiAgICAgIGlmIChVU0VfTU9DS19EQVRBKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGYWxsaW5nIGJhY2sgdG8gbW9jayBkYXRhIGR1ZSB0byBlcnJvcicpO1xuICAgICAgICByZXR1cm4gc2FtcGxlTGVhZGVyYm9hcmQuc2xpY2UoMCwgMTApO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEhlbHBlciBtZXRob2RzXG4gIHByaXZhdGUgc3RhdGljIGFzeW5jIHVwZGF0ZUhpZ2hTY29yZShcbiAgICBwbGF5ZXJVaWQ6IHN0cmluZywgXG4gICAgY2F0ZWdvcnk6IFNlYXJjaENhdGVnb3J5LCBcbiAgICBzY29yZTogbnVtYmVyXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwbGF5ZXJSZWYgPSBkb2MoZGIsICdwbGF5ZXJzJywgcGxheWVyVWlkKTtcbiAgICAgIGNvbnN0IHBsYXllckRvYyA9IGF3YWl0IGdldERvYyhwbGF5ZXJSZWYpO1xuICAgICAgXG4gICAgICBpZiAocGxheWVyRG9jLmV4aXN0cygpKSB7XG4gICAgICAgIGNvbnN0IHBsYXllckRhdGEgPSBwbGF5ZXJEb2MuZGF0YSgpO1xuICAgICAgICBjb25zdCBjdXJyZW50SGlnaFNjb3JlID0gcGxheWVyRGF0YS5oaWdoU2NvcmVzPy5bY2F0ZWdvcnldIHx8IDA7XG4gICAgICAgIFxuICAgICAgICBpZiAoc2NvcmUgPiBjdXJyZW50SGlnaFNjb3JlKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIHBsYXllcidzIGhpZ2ggc2NvcmUgZm9yIHRoaXMgY2F0ZWdvcnlcbiAgICAgICAgICBhd2FpdCB1cGRhdGVEb2MocGxheWVyUmVmLCB7XG4gICAgICAgICAgICBbYGhpZ2hTY29yZXMuJHtjYXRlZ29yeX1gXTogc2NvcmVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBbHNvIHVwZGF0ZSBsZWFkZXJib2FyZCBpZiBzY29yZSBpcyBzaWduaWZpY2FudFxuICAgICAgICAgIGlmIChzY29yZSA+IDUpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlYWRlcmJvYXJkUmVmID0gZG9jKGRiLCAnbGVhZGVyYm9hcmQnLCBgJHtjYXRlZ29yeX1fJHtwbGF5ZXJVaWR9YCk7XG4gICAgICAgICAgICBhd2FpdCBzZXREb2MobGVhZGVyYm9hcmRSZWYsIHtcbiAgICAgICAgICAgICAgdWlkOiBwbGF5ZXJVaWQsXG4gICAgICAgICAgICAgIG5hbWU6IHBsYXllckRhdGEubmFtZSB8fCAnVW5rbm93biBQbGF5ZXInLFxuICAgICAgICAgICAgICBzY29yZSxcbiAgICAgICAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgICAgICAgIHVwZGF0ZWRBdDogc2VydmVyVGltZXN0YW1wKClcbiAgICAgICAgICAgIH0sIHsgbWVyZ2U6IHRydWUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgaGlnaCBzY29yZTonLCBlcnJvcik7XG4gICAgICAvLyBEb24ndCB0aHJvdywganVzdCBsb2cgLSB0aGlzIGlzIGEgbm9uLWNyaXRpY2FsIG9wZXJhdGlvblxuICAgIH1cbiAgfVxuICBcbiAgcHJpdmF0ZSBzdGF0aWMgYXN5bmMgZmV0Y2hUZXJtc0J5Q2F0ZWdvcnkoY2F0ZWdvcnk6IFNlYXJjaENhdGVnb3J5KTogUHJvbWlzZTxTZWFyY2hUZXJtW10+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKFVTRV9NT0NLX0RBVEEpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1VzaW5nIG1vY2sgZGF0YSBmb3Igc2VhcmNoIHRlcm1zJyk7XG4gICAgICAgIFxuICAgICAgICBpZiAoY2F0ZWdvcnkgPT09ICdldmVyeXRoaW5nJykge1xuICAgICAgICAgIC8vIFJldHVybiBhbGwgc2FtcGxlIHRlcm1zXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVNlYXJjaFRlcm1zO1xuICAgICAgICB9IGVsc2UgaWYgKGNhdGVnb3J5ID09PSAnbGF0ZXN0Jykge1xuICAgICAgICAgIC8vIFJldHVybiB0ZXJtcyBzb3J0ZWQgYnkgdGltZXN0YW1wXG4gICAgICAgICAgcmV0dXJuIFsuLi5zYW1wbGVTZWFyY2hUZXJtc10uc29ydCgoKSA9PiBNYXRoLnJhbmRvbSgpIC0gMC41KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBGaWx0ZXIgYnkgY2F0ZWdvcnlcbiAgICAgICAgICBjb25zdCBmaWx0ZXJlZFRlcm1zID0gc2FtcGxlU2VhcmNoVGVybXMuZmlsdGVyKHRlcm0gPT4gdGVybS5jYXRlZ29yeSA9PT0gY2F0ZWdvcnkpO1xuICAgICAgICAgIHJldHVybiBmaWx0ZXJlZFRlcm1zLmxlbmd0aCA+IDAgPyBmaWx0ZXJlZFRlcm1zIDogc2FtcGxlU2VhcmNoVGVybXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgdGVybXNSZWYgPSBjb2xsZWN0aW9uKGRiLCAnc2VhcmNoVGVybXMnKTtcbiAgICAgIGxldCBxO1xuICAgICAgXG4gICAgICBpZiAoY2F0ZWdvcnkgPT09ICdldmVyeXRoaW5nJykge1xuICAgICAgICAvLyBGb3IgXCJldmVyeXRoaW5nXCIgY2F0ZWdvcnksIGdldCBhIG1peCBvZiBhbGwgY2F0ZWdvcmllc1xuICAgICAgICBxID0gcXVlcnkodGVybXNSZWYsIGxpbWl0KDUwKSk7XG4gICAgICB9IGVsc2UgaWYgKGNhdGVnb3J5ID09PSAnbGF0ZXN0Jykge1xuICAgICAgICAvLyBGb3IgXCJsYXRlc3RcIiwgZ2V0IHRoZSBtb3N0IHJlY2VudGx5IGFkZGVkIHRlcm1zXG4gICAgICAgIHEgPSBxdWVyeSh0ZXJtc1JlZiwgb3JkZXJCeSgndGltZXN0YW1wJywgJ2Rlc2MnKSwgbGltaXQoNTApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBzcGVjaWZpYyBjYXRlZ29yaWVzXG4gICAgICAgIHEgPSBxdWVyeSh0ZXJtc1JlZiwgd2hlcmUoJ2NhdGVnb3J5JywgJz09JywgY2F0ZWdvcnkpLCBsaW1pdCg1MCkpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhxKTtcbiAgICAgIGNvbnN0IHRlcm1zOiBTZWFyY2hUZXJtW10gPSBbXTtcbiAgICAgIFxuICAgICAgcXVlcnlTbmFwc2hvdC5mb3JFYWNoKChkb2MpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGRvYy5kYXRhKCkgYXMgU2VhcmNoVGVybTtcbiAgICAgICAgdGVybXMucHVzaCh7XG4gICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICBpZDogZG9jLmlkXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiB0ZXJtcztcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB0ZXJtczonLCBlcnJvcik7XG4gICAgICBcbiAgICAgIGlmIChVU0VfTU9DS19EQVRBKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGYWxsaW5nIGJhY2sgdG8gbW9jayBkYXRhIGR1ZSB0byBlcnJvcicpO1xuICAgICAgICByZXR1cm4gc2FtcGxlU2VhcmNoVGVybXM7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgcHJpdmF0ZSBzdGF0aWMgYXN5bmMgZmV0Y2hDdXN0b21UZXJtV2l0aFJlbGF0ZWQoY3VzdG9tVGVybTogc3RyaW5nKTogUHJvbWlzZTxTZWFyY2hUZXJtW10+IHtcbiAgICB0cnkge1xuICAgICAgLy8gVGhpcyB3b3VsZCB0eXBpY2FsbHkgY2FsbCBhIEZpcmViYXNlIEZ1bmN0aW9uIHRvIGdldCB0aGUgY3VzdG9tIHRlcm0gZGF0YVxuICAgICAgLy8gRm9yIG5vdywgd2UnbGwgc2ltdWxhdGUgaXQgd2l0aCBhIHBsYWNlaG9sZGVyXG4gICAgICBcbiAgICAgIC8vIEZpcnN0IHRlcm0gd2lsbCBiZSB0aGUgY3VzdG9tIG9uZVxuICAgICAgY29uc3QgY3VzdG9tU2VhcmNoVGVybTogU2VhcmNoVGVybSA9IHtcbiAgICAgICAgaWQ6IHV1aWR2NCgpLFxuICAgICAgICB0ZXJtOiBjdXN0b21UZXJtLFxuICAgICAgICB2b2x1bWU6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMCkgKyAxLCAvLyBQbGFjZWhvbGRlciB2b2x1bWVcbiAgICAgICAgY2F0ZWdvcnk6ICdjdXN0b20nLFxuICAgICAgICBpbWFnZVVybDogYGh0dHBzOi8vc291cmNlLnVuc3BsYXNoLmNvbS9mZWF0dXJlZC8/JHtlbmNvZGVVUklDb21wb25lbnQoY3VzdG9tVGVybSl9YCxcbiAgICAgICAgdGltZXN0YW1wOiBUaW1lc3RhbXAubm93KClcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIFRoZW4gZ2V0IHNvbWUgcmVsYXRlZCB0ZXJtcyBmcm9tIHRoZSBkYXRhYmFzZSAocmFuZG9tIGZvciBub3cpXG4gICAgICBjb25zdCB0ZXJtc1JlZiA9IGNvbGxlY3Rpb24oZGIsICdzZWFyY2hUZXJtcycpO1xuICAgICAgY29uc3QgcSA9IHF1ZXJ5KHRlcm1zUmVmLCBsaW1pdCgyMCkpO1xuICAgICAgY29uc3QgcXVlcnlTbmFwc2hvdCA9IGF3YWl0IGdldERvY3MocSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHRlcm1zOiBTZWFyY2hUZXJtW10gPSBbY3VzdG9tU2VhcmNoVGVybV07XG4gICAgICBcbiAgICAgIHF1ZXJ5U25hcHNob3QuZm9yRWFjaCgoZG9jKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBkb2MuZGF0YSgpIGFzIFNlYXJjaFRlcm07XG4gICAgICAgIHRlcm1zLnB1c2goe1xuICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgaWQ6IGRvYy5pZFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4gdGVybXM7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgY3VzdG9tIHRlcm06JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICBwcml2YXRlIHN0YXRpYyBzaHVmZmxlVGVybXModGVybXM6IFNlYXJjaFRlcm1bXSk6IFNlYXJjaFRlcm1bXSB7XG4gICAgY29uc3Qgc2h1ZmZsZWQgPSBbLi4udGVybXNdO1xuICAgIGZvciAobGV0IGkgPSBzaHVmZmxlZC5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICBjb25zdCBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGkgKyAxKSk7XG4gICAgICBbc2h1ZmZsZWRbaV0sIHNodWZmbGVkW2pdXSA9IFtzaHVmZmxlZFtqXSwgc2h1ZmZsZWRbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gc2h1ZmZsZWQ7XG4gIH1cbiAgXG4gIHByaXZhdGUgc3RhdGljIGdlbmVyYXRlR2FtZUlkKCk6IHN0cmluZyB7XG4gICAgLy8gR2VuZXJhdGUgYSA2LWNoYXJhY3RlciBhbHBoYW51bWVyaWMgY29kZSAodXBwZXJjYXNlKVxuICAgIGNvbnN0IGNoYXJzID0gJ0FCQ0RFRkdISktMTU5QUVJTVFVWV1hZWjIzNDU2Nzg5JzsgLy8gUmVtb3ZlZCBjb25mdXNhYmxlIGNoYXJhY3RlcnNcbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgIHJlc3VsdCArPSBjaGFycy5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcnMubGVuZ3RoKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0iXSwibmFtZXMiOlsiZG9jIiwic2V0RG9jIiwidXBkYXRlRG9jIiwiZ2V0RG9jIiwiY29sbGVjdGlvbiIsInF1ZXJ5Iiwid2hlcmUiLCJnZXREb2NzIiwiVGltZXN0YW1wIiwic2VydmVyVGltZXN0YW1wIiwibGltaXQiLCJvcmRlckJ5IiwiZGIiLCJ2NCIsInV1aWR2NCIsInNhbXBsZVNlYXJjaFRlcm1zIiwic2FtcGxlTGVhZGVyYm9hcmQiLCJVU0VfTU9DS19EQVRBIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1VTRV9NT0NLX0RBVEEiLCJUcmVuZEd1ZXNzZXJTZXJ2aWNlIiwic3RhcnRHYW1lIiwiZ2FtZUlkIiwiY2F0ZWdvcnkiLCJjdXN0b21UZXJtIiwiZ2FtZVJlZiIsInRvVXBwZXJDYXNlIiwiZ2FtZURvYyIsImV4aXN0cyIsIkVycm9yIiwiY29uc29sZSIsImxvZyIsInRlcm1zIiwiZmV0Y2hDdXN0b21UZXJtV2l0aFJlbGF0ZWQiLCJmZXRjaFRlcm1zQnlDYXRlZ29yeSIsImxlbmd0aCIsInNodWZmbGVkVGVybXMiLCJzaHVmZmxlVGVybXMiLCJnYW1lU3RhdGUiLCJjdXJyZW50Um91bmQiLCJrbm93blRlcm0iLCJoaWRkZW5UZXJtIiwic3RhcnRlZCIsImZpbmlzaGVkIiwidXNlZFRlcm1zIiwiaWQiLCJzbGljZSIsInVuZGVmaW5lZCIsInN0YXR1cyIsInNlc3Npb25TdG9yYWdlIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJnZXRJdGVtIiwidWlkIiwibmFtZSIsInNjb3JlIiwiZXJyb3IiLCJtYWtlR3Vlc3MiLCJwbGF5ZXJVaWQiLCJpc0hpZ2hlciIsImdhbWVEYXRhIiwiZGF0YSIsInBsYXllciIsImlzQ29ycmVjdCIsInZvbHVtZSIsIm5leHRSb3VuZCIsIm5ld1BsYXllclNjb3JlIiwibmV4dFRlcm0iLCJyZW1haW5pbmdUZXJtcyIsInVwZGF0ZWRTdGF0ZSIsIndpbm5lciIsInVwZGF0ZUhpZ2hTY29yZSIsImVuZEdhbWUiLCJmaW5hbFNjb3JlIiwiY3JlYXRlR2FtZSIsImNyZWF0ZWRCeSIsInBsYXllck5hbWUiLCJnZW5lcmF0ZUdhbWVJZCIsInBsYXllckRhdGEiLCJjcmVhdGVkQXQiLCJnYW1lVHlwZSIsImdldExlYWRlcmJvYXJkIiwiZmlsdGVyIiwiaGlnaFNjb3JlcyIsInNvcnQiLCJhIiwiYiIsInNjb3JlQSIsInNjb3JlQiIsImxlYWRlcmJvYXJkUmVmIiwicSIsInF1ZXJ5U25hcHNob3QiLCJsZWFkZXJib2FyZCIsImZvckVhY2giLCJwdXNoIiwicGxheWVyUmVmIiwicGxheWVyRG9jIiwiY3VycmVudEhpZ2hTY29yZSIsInVwZGF0ZWRBdCIsIm1lcmdlIiwiTWF0aCIsInJhbmRvbSIsImZpbHRlcmVkVGVybXMiLCJ0ZXJtIiwidGVybXNSZWYiLCJjdXN0b21TZWFyY2hUZXJtIiwiZmxvb3IiLCJpbWFnZVVybCIsImVuY29kZVVSSUNvbXBvbmVudCIsInRpbWVzdGFtcCIsIm5vdyIsInNodWZmbGVkIiwiaSIsImoiLCJjaGFycyIsInJlc3VsdCIsImNoYXJBdCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/lib/firebase/trendGuesserService.ts\n"));

/***/ })

});