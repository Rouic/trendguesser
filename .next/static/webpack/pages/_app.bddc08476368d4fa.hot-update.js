"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "(pages-dir-browser)/./src/lib/firebase/trendGuesserService.ts":
/*!*************************************************!*\
  !*** ./src/lib/firebase/trendGuesserService.ts ***!
  \*************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TrendGuesserService: () => (/* binding */ TrendGuesserService)\n/* harmony export */ });\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/firestore */ \"(pages-dir-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./firebase */ \"(pages-dir-browser)/./src/lib/firebase/firebase.ts\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// src/lib/firebase/trendGuesserService.ts\n\n\n\n// Development mode flag\nconst USE_MOCK_DATA = process.env.NEXT_PUBLIC_USE_MOCK_DATA === 'true' || \"development\" === 'development';\nclass TrendGuesserService {\n    // Start a new game with selected category\n    static async startGame(gameId, category, customTerm) {\n        try {\n            const gameRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'games', gameId.toUpperCase());\n            const gameDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(gameRef);\n            if (!gameDoc.exists()) {\n                throw new Error('Game does not exist');\n            }\n            // Get terms for the selected category\n            let terms = [];\n            if (category === 'custom' && customTerm) {\n                // For custom games, fetch the custom term and related terms\n                terms = await this.fetchCustomTermWithRelated(customTerm);\n            } else {\n                // For predefined categories, fetch terms from the database\n                terms = await this.fetchTermsByCategory(category);\n            }\n            if (terms.length < 2) {\n                throw new Error('Not enough terms available');\n            }\n            // Shuffle the terms\n            const shuffledTerms = this.shuffleTerms(terms);\n            // Initialize game state with first two terms\n            const gameState = {\n                currentRound: 1,\n                knownTerm: shuffledTerms[0],\n                hiddenTerm: shuffledTerms[1],\n                category,\n                started: true,\n                finished: false,\n                usedTerms: [\n                    shuffledTerms[0].id,\n                    shuffledTerms[1].id\n                ],\n                terms: shuffledTerms.slice(2),\n                customTerm: category === 'custom' ? customTerm : undefined\n            };\n            // Update the game document with new game state\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(gameRef, {\n                status: 'active',\n                '__trendguesser.state': gameState\n            });\n        } catch (error) {\n            console.error('Error starting game:', error);\n            throw error;\n        }\n    }\n    // Make a guess (higher or lower)\n    static async makeGuess(gameId, playerUid, isHigher) {\n        try {\n            const gameRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'games', gameId.toUpperCase());\n            const gameDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(gameRef);\n            if (!gameDoc.exists()) {\n                throw new Error('Game does not exist');\n            }\n            const gameData = gameDoc.data();\n            const gameState = gameData['__trendguesser.state'];\n            const player = gameData[playerUid];\n            if (!gameState || !gameState.started || gameState.finished) {\n                throw new Error('Game is not active');\n            }\n            // Check if the guess is correct\n            const isCorrect = isHigher ? gameState.hiddenTerm.volume > gameState.knownTerm.volume : gameState.hiddenTerm.volume < gameState.knownTerm.volume;\n            if (isCorrect) {\n                // Correct guess - prepare next round\n                const nextRound = gameState.currentRound + 1;\n                const newPlayerScore = (player.score || 0) + 1;\n                // Update player score\n                await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(gameRef, {\n                    [\"\".concat(playerUid, \".score\")]: newPlayerScore\n                });\n                // If we have more terms, set up next round\n                if (gameState.terms.length > 0) {\n                    const nextTerm = gameState.terms[0];\n                    const remainingTerms = gameState.terms.slice(1);\n                    const updatedState = {\n                        ...gameState,\n                        currentRound: nextRound,\n                        knownTerm: gameState.hiddenTerm,\n                        hiddenTerm: nextTerm,\n                        usedTerms: [\n                            ...gameState.usedTerms,\n                            nextTerm.id\n                        ],\n                        terms: remainingTerms\n                    };\n                    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(gameRef, {\n                        '__trendguesser.state': updatedState\n                    });\n                } else {\n                    // No more terms - player wins by completing all terms\n                    const updatedState = {\n                        ...gameState,\n                        finished: true,\n                        winner: playerUid\n                    };\n                    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(gameRef, {\n                        '__trendguesser.state': updatedState,\n                        status: 'finished'\n                    });\n                    // Update high score if needed\n                    await this.updateHighScore(playerUid, gameState.category, newPlayerScore);\n                }\n                return true;\n            } else {\n                // Incorrect guess - game over\n                const updatedState = {\n                    ...gameState,\n                    finished: true\n                };\n                await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(gameRef, {\n                    '__trendguesser.state': updatedState,\n                    status: 'finished'\n                });\n                // Update high score if needed\n                await this.updateHighScore(playerUid, gameState.category, player.score || 0);\n                return false;\n            }\n        } catch (error) {\n            console.error('Error making guess:', error);\n            throw error;\n        }\n    }\n    // End the game and update high scores\n    static async endGame(gameId, playerUid, finalScore) {\n        try {\n            const gameRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'games', gameId.toUpperCase());\n            const gameDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(gameRef);\n            if (!gameDoc.exists()) {\n                throw new Error('Game does not exist');\n            }\n            const gameData = gameDoc.data();\n            const gameState = gameData['__trendguesser.state'];\n            if (!gameState) {\n                throw new Error('No game state found');\n            }\n            // Only update if game was actually started\n            if (gameState.started) {\n                // Mark game as finished\n                await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(gameRef, {\n                    status: 'finished',\n                    '__trendguesser.state': {\n                        ...gameState,\n                        finished: true\n                    }\n                });\n                // Update high score if needed\n                await this.updateHighScore(playerUid, gameState.category, finalScore);\n            }\n        } catch (error) {\n            console.error('Error ending game:', error);\n            throw error;\n        }\n    }\n    // Create a new game session\n    static async createGame(createdBy, playerName) {\n        try {\n            // Generate a short 6-character game ID (uppercase)\n            const gameId = this.generateGameId();\n            if (USE_MOCK_DATA) {\n                console.log('Using mock data for game creation');\n                // Return the game ID without actually writing to Firestore\n                return gameId;\n            }\n            const gameRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'games', gameId);\n            // Initialize player data\n            const playerData = {\n                uid: createdBy,\n                name: playerName || 'Player',\n                score: 0\n            };\n            // Initial game data\n            const gameData = {\n                id: gameId,\n                createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n                createdBy,\n                gameType: 'trendguesser',\n                status: 'waiting',\n                [createdBy]: playerData\n            };\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setDoc)(gameRef, gameData);\n            return gameId;\n        } catch (error) {\n            console.error('Error creating game:', error);\n            if (USE_MOCK_DATA) {\n                console.log('Falling back to mock data due to error');\n                return this.generateGameId();\n            }\n            throw error;\n        }\n    }\n    // Fetch leaderboard for a category\n    static async getLeaderboard(category) {\n        try {\n            const leaderboardRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'leaderboard');\n            const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(leaderboardRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('category', '==', category), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)('score', 'desc'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.limit)(10));\n            const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n            const leaderboard = [];\n            querySnapshot.forEach((doc)=>{\n                const data = doc.data();\n                leaderboard.push({\n                    uid: data.uid,\n                    name: data.name,\n                    score: data.score,\n                    highScores: data.highScores\n                });\n            });\n            return leaderboard;\n        } catch (error) {\n            console.error('Error fetching leaderboard:', error);\n            throw error;\n        }\n    }\n    // Helper methods\n    static async updateHighScore(playerUid, category, score) {\n        try {\n            const playerRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'players', playerUid);\n            const playerDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(playerRef);\n            if (playerDoc.exists()) {\n                var _playerData_highScores;\n                const playerData = playerDoc.data();\n                const currentHighScore = ((_playerData_highScores = playerData.highScores) === null || _playerData_highScores === void 0 ? void 0 : _playerData_highScores[category]) || 0;\n                if (score > currentHighScore) {\n                    // Update player's high score for this category\n                    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(playerRef, {\n                        [\"highScores.\".concat(category)]: score\n                    });\n                    // Also update leaderboard if score is significant\n                    if (score > 5) {\n                        const leaderboardRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'leaderboard', \"\".concat(category, \"_\").concat(playerUid));\n                        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setDoc)(leaderboardRef, {\n                            uid: playerUid,\n                            name: playerData.name || 'Unknown Player',\n                            score,\n                            category,\n                            updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)()\n                        }, {\n                            merge: true\n                        });\n                    }\n                }\n            }\n        } catch (error) {\n            console.error('Error updating high score:', error);\n        // Don't throw, just log - this is a non-critical operation\n        }\n    }\n    static async fetchTermsByCategory(category) {\n        try {\n            const termsRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'searchTerms');\n            let q;\n            if (category === 'everything') {\n                // For \"everything\" category, get a mix of all categories\n                q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(termsRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.limit)(50));\n            } else if (category === 'latest') {\n                // For \"latest\", get the most recently added terms\n                q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(termsRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)('timestamp', 'desc'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.limit)(50));\n            } else {\n                // For specific categories\n                q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(termsRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('category', '==', category), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.limit)(50));\n            }\n            const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n            const terms = [];\n            querySnapshot.forEach((doc)=>{\n                const data = doc.data();\n                terms.push({\n                    ...data,\n                    id: doc.id\n                });\n            });\n            return terms;\n        } catch (error) {\n            console.error('Error fetching terms:', error);\n            throw error;\n        }\n    }\n    static async fetchCustomTermWithRelated(customTerm) {\n        try {\n            // This would typically call a Firebase Function to get the custom term data\n            // For now, we'll simulate it with a placeholder\n            // First term will be the custom one\n            const customSearchTerm = {\n                id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__.v4)(),\n                term: customTerm,\n                volume: Math.floor(Math.random() * 100) + 1,\n                category: 'custom',\n                imageUrl: \"https://source.unsplash.com/featured/?\".concat(encodeURIComponent(customTerm)),\n                timestamp: firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.Timestamp.now()\n            };\n            // Then get some related terms from the database (random for now)\n            const termsRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'searchTerms');\n            const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(termsRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.limit)(20));\n            const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n            const terms = [\n                customSearchTerm\n            ];\n            querySnapshot.forEach((doc)=>{\n                const data = doc.data();\n                terms.push({\n                    ...data,\n                    id: doc.id\n                });\n            });\n            return terms;\n        } catch (error) {\n            console.error('Error fetching custom term:', error);\n            throw error;\n        }\n    }\n    static shuffleTerms(terms) {\n        const shuffled = [\n            ...terms\n        ];\n        for(let i = shuffled.length - 1; i > 0; i--){\n            const j = Math.floor(Math.random() * (i + 1));\n            [shuffled[i], shuffled[j]] = [\n                shuffled[j],\n                shuffled[i]\n            ];\n        }\n        return shuffled;\n    }\n    static generateGameId() {\n        // Generate a 6-character alphanumeric code (uppercase)\n        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Removed confusable characters\n        let result = '';\n        for(let i = 0; i < 6; i++){\n            result += chars.charAt(Math.floor(Math.random() * chars.length));\n        }\n        return result;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9saWIvZmlyZWJhc2UvdHJlbmRHdWVzc2VyU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLDBDQUEwQztBQWdCZDtBQUNJO0FBQ0k7QUFJcEMsd0JBQXdCO0FBQ3hCLE1BQU1lLGdCQUFnQkMsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyx5QkFBeUIsS0FBSyxVQUN6Q0Ysa0JBQXlCO0FBRXpDLE1BQU1HO0lBQ1gsMENBQTBDO0lBQzFDLGFBQWFDLFVBQVVDLE1BQWMsRUFBRUMsUUFBd0IsRUFBRUMsVUFBbUIsRUFBaUI7UUFDbkcsSUFBSTtZQUNGLE1BQU1DLFVBQVV4Qix1REFBR0EsQ0FBQ1kseUNBQUVBLEVBQUUsU0FBU1MsT0FBT0ksV0FBVztZQUNuRCxNQUFNQyxVQUFVLE1BQU12QiwwREFBTUEsQ0FBQ3FCO1lBRTdCLElBQUksQ0FBQ0UsUUFBUUMsTUFBTSxJQUFJO2dCQUNyQixNQUFNLElBQUlDLE1BQU07WUFDbEI7WUFFQSxzQ0FBc0M7WUFDdEMsSUFBSUMsUUFBc0IsRUFBRTtZQUU1QixJQUFJUCxhQUFhLFlBQVlDLFlBQVk7Z0JBQ3ZDLDREQUE0RDtnQkFDNURNLFFBQVEsTUFBTSxJQUFJLENBQUNDLDBCQUEwQixDQUFDUDtZQUNoRCxPQUFPO2dCQUNMLDJEQUEyRDtnQkFDM0RNLFFBQVEsTUFBTSxJQUFJLENBQUNFLG9CQUFvQixDQUFDVDtZQUMxQztZQUVBLElBQUlPLE1BQU1HLE1BQU0sR0FBRyxHQUFHO2dCQUNwQixNQUFNLElBQUlKLE1BQU07WUFDbEI7WUFFQSxvQkFBb0I7WUFDcEIsTUFBTUssZ0JBQWdCLElBQUksQ0FBQ0MsWUFBWSxDQUFDTDtZQUV4Qyw2Q0FBNkM7WUFDN0MsTUFBTU0sWUFBbUM7Z0JBQ3ZDQyxjQUFjO2dCQUNkQyxXQUFXSixhQUFhLENBQUMsRUFBRTtnQkFDM0JLLFlBQVlMLGFBQWEsQ0FBQyxFQUFFO2dCQUM1Qlg7Z0JBQ0FpQixTQUFTO2dCQUNUQyxVQUFV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LENBQUFBLElBQUk7WUFDMUMsQ0FBQ0QsUUFBUSxDQUFDQyxFQUFFLEVBQUVELFFBQVEsQ0FBQ0UsRUFBRSxDQUFDLEdBQUc7Z0JBQUNGLFFBQVEsQ0FBQ0UsRUFBRTtnQkFBRUYsUUFBUSxDQUFDQyxFQUFFO2FBQUM7UUFDekQ7UUFDQSxPQUFPRDtJQUNUO0lBRUEsT0FBZTlCLGlCQUF5QjtRQUN0Qyx1REFBdUQ7UUFDdkQsTUFBTWlDLFFBQVEsb0NBQW9DLGdDQUFnQztRQUNsRixJQUFJQyxTQUFTO1FBQ2IsSUFBSyxJQUFJSCxJQUFJLEdBQUdBLElBQUksR0FBR0EsSUFBSztZQUMxQkcsVUFBVUQsTUFBTUUsTUFBTSxDQUFDWixLQUFLQyxLQUFLLENBQUNELEtBQUtFLE1BQU0sS0FBS1EsTUFBTXRFLE1BQU07UUFDaEU7UUFDQSxPQUFPdUU7SUFDVDtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvYWxleC9EZXZlbG9wZXIvdHJlbmRndWVzc2VyL3NyYy9saWIvZmlyZWJhc2UvdHJlbmRHdWVzc2VyU2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvbGliL2ZpcmViYXNlL3RyZW5kR3Vlc3NlclNlcnZpY2UudHNcbmltcG9ydCB7IFxuICBkb2MsIFxuICBzZXREb2MsIFxuICB1cGRhdGVEb2MsIFxuICBnZXREb2MsIFxuICBjb2xsZWN0aW9uLCBcbiAgcXVlcnksIFxuICB3aGVyZSwgXG4gIGdldERvY3MsIFxuICBhcnJheVVuaW9uLCBcbiAgVGltZXN0YW1wLCBcbiAgc2VydmVyVGltZXN0YW1wLFxuICBpbmNyZW1lbnQsXG4gIGxpbWl0LFxuICBvcmRlckJ5XG59IGZyb20gJ2ZpcmViYXNlL2ZpcmVzdG9yZSc7XG5pbXBvcnQgeyBkYiB9IGZyb20gJy4vZmlyZWJhc2UnO1xuaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSAndXVpZCc7XG5pbXBvcnQgeyBTZWFyY2hDYXRlZ29yeSwgU2VhcmNoVGVybSwgVHJlbmRHdWVzc2VyR2FtZVN0YXRlLCBUcmVuZEd1ZXNzZXJQbGF5ZXIgfSBmcm9tICdAL3R5cGVzJztcbmltcG9ydCB7IHNhbXBsZVNlYXJjaFRlcm1zLCBzYW1wbGVMZWFkZXJib2FyZCB9IGZyb20gJy4vbW9ja0RhdGEnO1xuXG4vLyBEZXZlbG9wbWVudCBtb2RlIGZsYWdcbmNvbnN0IFVTRV9NT0NLX0RBVEEgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19VU0VfTU9DS19EQVRBID09PSAndHJ1ZScgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnO1xuXG5leHBvcnQgY2xhc3MgVHJlbmRHdWVzc2VyU2VydmljZSB7XG4gIC8vIFN0YXJ0IGEgbmV3IGdhbWUgd2l0aCBzZWxlY3RlZCBjYXRlZ29yeVxuICBzdGF0aWMgYXN5bmMgc3RhcnRHYW1lKGdhbWVJZDogc3RyaW5nLCBjYXRlZ29yeTogU2VhcmNoQ2F0ZWdvcnksIGN1c3RvbVRlcm0/OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZ2FtZVJlZiA9IGRvYyhkYiwgJ2dhbWVzJywgZ2FtZUlkLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgY29uc3QgZ2FtZURvYyA9IGF3YWl0IGdldERvYyhnYW1lUmVmKTtcbiAgICAgIFxuICAgICAgaWYgKCFnYW1lRG9jLmV4aXN0cygpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignR2FtZSBkb2VzIG5vdCBleGlzdCcpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBHZXQgdGVybXMgZm9yIHRoZSBzZWxlY3RlZCBjYXRlZ29yeVxuICAgICAgbGV0IHRlcm1zOiBTZWFyY2hUZXJtW10gPSBbXTtcbiAgICAgIFxuICAgICAgaWYgKGNhdGVnb3J5ID09PSAnY3VzdG9tJyAmJiBjdXN0b21UZXJtKSB7XG4gICAgICAgIC8vIEZvciBjdXN0b20gZ2FtZXMsIGZldGNoIHRoZSBjdXN0b20gdGVybSBhbmQgcmVsYXRlZCB0ZXJtc1xuICAgICAgICB0ZXJtcyA9IGF3YWl0IHRoaXMuZmV0Y2hDdXN0b21UZXJtV2l0aFJlbGF0ZWQoY3VzdG9tVGVybSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3IgcHJlZGVmaW5lZCBjYXRlZ29yaWVzLCBmZXRjaCB0ZXJtcyBmcm9tIHRoZSBkYXRhYmFzZVxuICAgICAgICB0ZXJtcyA9IGF3YWl0IHRoaXMuZmV0Y2hUZXJtc0J5Q2F0ZWdvcnkoY2F0ZWdvcnkpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAodGVybXMubGVuZ3RoIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBlbm91Z2ggdGVybXMgYXZhaWxhYmxlJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNodWZmbGUgdGhlIHRlcm1zXG4gICAgICBjb25zdCBzaHVmZmxlZFRlcm1zID0gdGhpcy5zaHVmZmxlVGVybXModGVybXMpO1xuICAgICAgXG4gICAgICAvLyBJbml0aWFsaXplIGdhbWUgc3RhdGUgd2l0aCBmaXJzdCB0d28gdGVybXNcbiAgICAgIGNvbnN0IGdhbWVTdGF0ZTogVHJlbmRHdWVzc2VyR2FtZVN0YXRlID0ge1xuICAgICAgICBjdXJyZW50Um91bmQ6IDEsXG4gICAgICAgIGtub3duVGVybTogc2h1ZmZsZWRUZXJtc1swXSxcbiAgICAgICAgaGlkZGVuVGVybTogc2h1ZmZsZWRUZXJtc1sxXSxcbiAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgIHN0YXJ0ZWQ6IHRydWUsXG4gICAgICAgIGZpbmlzaGVkOiBmYWxzZSxcbiAgICAgICAgdXNlZFRlcm1zOiBbc2h1ZmZsZWRUZXJtc1swXS5pZCwgc2h1ZmZsZWRUZXJtc1sxXS5pZF0sXG4gICAgICAgIHRlcm1zOiBzaHVmZmxlZFRlcm1zLnNsaWNlKDIpLCAvLyBTdG9yZSByZW1haW5pbmcgdGVybXNcbiAgICAgICAgY3VzdG9tVGVybTogY2F0ZWdvcnkgPT09ICdjdXN0b20nID8gY3VzdG9tVGVybSA6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHRoZSBnYW1lIGRvY3VtZW50IHdpdGggbmV3IGdhbWUgc3RhdGVcbiAgICAgIGF3YWl0IHVwZGF0ZURvYyhnYW1lUmVmLCB7XG4gICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgICdfX3RyZW5kZ3Vlc3Nlci5zdGF0ZSc6IGdhbWVTdGF0ZVxuICAgICAgfSk7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc3RhcnRpbmcgZ2FtZTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIE1ha2UgYSBndWVzcyAoaGlnaGVyIG9yIGxvd2VyKVxuICBzdGF0aWMgYXN5bmMgbWFrZUd1ZXNzKGdhbWVJZDogc3RyaW5nLCBwbGF5ZXJVaWQ6IHN0cmluZywgaXNIaWdoZXI6IGJvb2xlYW4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZ2FtZVJlZiA9IGRvYyhkYiwgJ2dhbWVzJywgZ2FtZUlkLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgY29uc3QgZ2FtZURvYyA9IGF3YWl0IGdldERvYyhnYW1lUmVmKTtcbiAgICAgIFxuICAgICAgaWYgKCFnYW1lRG9jLmV4aXN0cygpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignR2FtZSBkb2VzIG5vdCBleGlzdCcpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBnYW1lRGF0YSA9IGdhbWVEb2MuZGF0YSgpO1xuICAgICAgY29uc3QgZ2FtZVN0YXRlID0gZ2FtZURhdGFbJ19fdHJlbmRndWVzc2VyLnN0YXRlJ10gYXMgVHJlbmRHdWVzc2VyR2FtZVN0YXRlO1xuICAgICAgY29uc3QgcGxheWVyID0gZ2FtZURhdGFbcGxheWVyVWlkXSBhcyBUcmVuZEd1ZXNzZXJQbGF5ZXI7XG4gICAgICBcbiAgICAgIGlmICghZ2FtZVN0YXRlIHx8ICFnYW1lU3RhdGUuc3RhcnRlZCB8fCBnYW1lU3RhdGUuZmluaXNoZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHYW1lIGlzIG5vdCBhY3RpdmUnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGd1ZXNzIGlzIGNvcnJlY3RcbiAgICAgIGNvbnN0IGlzQ29ycmVjdCA9IGlzSGlnaGVyIFxuICAgICAgICA/IGdhbWVTdGF0ZS5oaWRkZW5UZXJtLnZvbHVtZSA+IGdhbWVTdGF0ZS5rbm93blRlcm0udm9sdW1lXG4gICAgICAgIDogZ2FtZVN0YXRlLmhpZGRlblRlcm0udm9sdW1lIDwgZ2FtZVN0YXRlLmtub3duVGVybS52b2x1bWU7XG4gICAgICBcbiAgICAgIGlmIChpc0NvcnJlY3QpIHtcbiAgICAgICAgLy8gQ29ycmVjdCBndWVzcyAtIHByZXBhcmUgbmV4dCByb3VuZFxuICAgICAgICBjb25zdCBuZXh0Um91bmQgPSBnYW1lU3RhdGUuY3VycmVudFJvdW5kICsgMTtcbiAgICAgICAgY29uc3QgbmV3UGxheWVyU2NvcmUgPSAocGxheWVyLnNjb3JlIHx8IDApICsgMTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBwbGF5ZXIgc2NvcmVcbiAgICAgICAgYXdhaXQgdXBkYXRlRG9jKGdhbWVSZWYsIHtcbiAgICAgICAgICBbYCR7cGxheWVyVWlkfS5zY29yZWBdOiBuZXdQbGF5ZXJTY29yZVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIElmIHdlIGhhdmUgbW9yZSB0ZXJtcywgc2V0IHVwIG5leHQgcm91bmRcbiAgICAgICAgaWYgKGdhbWVTdGF0ZS50ZXJtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgbmV4dFRlcm0gPSBnYW1lU3RhdGUudGVybXNbMF07XG4gICAgICAgICAgY29uc3QgcmVtYWluaW5nVGVybXMgPSBnYW1lU3RhdGUudGVybXMuc2xpY2UoMSk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgdXBkYXRlZFN0YXRlOiBUcmVuZEd1ZXNzZXJHYW1lU3RhdGUgPSB7XG4gICAgICAgICAgICAuLi5nYW1lU3RhdGUsXG4gICAgICAgICAgICBjdXJyZW50Um91bmQ6IG5leHRSb3VuZCxcbiAgICAgICAgICAgIGtub3duVGVybTogZ2FtZVN0YXRlLmhpZGRlblRlcm0sXG4gICAgICAgICAgICBoaWRkZW5UZXJtOiBuZXh0VGVybSxcbiAgICAgICAgICAgIHVzZWRUZXJtczogWy4uLmdhbWVTdGF0ZS51c2VkVGVybXMsIG5leHRUZXJtLmlkXSxcbiAgICAgICAgICAgIHRlcm1zOiByZW1haW5pbmdUZXJtc1xuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgYXdhaXQgdXBkYXRlRG9jKGdhbWVSZWYsIHtcbiAgICAgICAgICAgICdfX3RyZW5kZ3Vlc3Nlci5zdGF0ZSc6IHVwZGF0ZWRTdGF0ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vIG1vcmUgdGVybXMgLSBwbGF5ZXIgd2lucyBieSBjb21wbGV0aW5nIGFsbCB0ZXJtc1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRTdGF0ZTogVHJlbmRHdWVzc2VyR2FtZVN0YXRlID0ge1xuICAgICAgICAgICAgLi4uZ2FtZVN0YXRlLFxuICAgICAgICAgICAgZmluaXNoZWQ6IHRydWUsXG4gICAgICAgICAgICB3aW5uZXI6IHBsYXllclVpZFxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgYXdhaXQgdXBkYXRlRG9jKGdhbWVSZWYsIHtcbiAgICAgICAgICAgICdfX3RyZW5kZ3Vlc3Nlci5zdGF0ZSc6IHVwZGF0ZWRTdGF0ZSxcbiAgICAgICAgICAgIHN0YXR1czogJ2ZpbmlzaGVkJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFVwZGF0ZSBoaWdoIHNjb3JlIGlmIG5lZWRlZFxuICAgICAgICAgIGF3YWl0IHRoaXMudXBkYXRlSGlnaFNjb3JlKHBsYXllclVpZCwgZ2FtZVN0YXRlLmNhdGVnb3J5LCBuZXdQbGF5ZXJTY29yZSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW5jb3JyZWN0IGd1ZXNzIC0gZ2FtZSBvdmVyXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRTdGF0ZTogVHJlbmRHdWVzc2VyR2FtZVN0YXRlID0ge1xuICAgICAgICAgIC4uLmdhbWVTdGF0ZSxcbiAgICAgICAgICBmaW5pc2hlZDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgdXBkYXRlRG9jKGdhbWVSZWYsIHtcbiAgICAgICAgICAnX190cmVuZGd1ZXNzZXIuc3RhdGUnOiB1cGRhdGVkU3RhdGUsXG4gICAgICAgICAgc3RhdHVzOiAnZmluaXNoZWQnXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIGhpZ2ggc2NvcmUgaWYgbmVlZGVkXG4gICAgICAgIGF3YWl0IHRoaXMudXBkYXRlSGlnaFNjb3JlKHBsYXllclVpZCwgZ2FtZVN0YXRlLmNhdGVnb3J5LCBwbGF5ZXIuc2NvcmUgfHwgMCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbWFraW5nIGd1ZXNzOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gRW5kIHRoZSBnYW1lIGFuZCB1cGRhdGUgaGlnaCBzY29yZXNcbiAgc3RhdGljIGFzeW5jIGVuZEdhbWUoZ2FtZUlkOiBzdHJpbmcsIHBsYXllclVpZDogc3RyaW5nLCBmaW5hbFNjb3JlOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZ2FtZVJlZiA9IGRvYyhkYiwgJ2dhbWVzJywgZ2FtZUlkLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgY29uc3QgZ2FtZURvYyA9IGF3YWl0IGdldERvYyhnYW1lUmVmKTtcbiAgICAgIFxuICAgICAgaWYgKCFnYW1lRG9jLmV4aXN0cygpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignR2FtZSBkb2VzIG5vdCBleGlzdCcpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBnYW1lRGF0YSA9IGdhbWVEb2MuZGF0YSgpO1xuICAgICAgY29uc3QgZ2FtZVN0YXRlID0gZ2FtZURhdGFbJ19fdHJlbmRndWVzc2VyLnN0YXRlJ10gYXMgVHJlbmRHdWVzc2VyR2FtZVN0YXRlO1xuICAgICAgXG4gICAgICBpZiAoIWdhbWVTdGF0ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGdhbWUgc3RhdGUgZm91bmQnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gT25seSB1cGRhdGUgaWYgZ2FtZSB3YXMgYWN0dWFsbHkgc3RhcnRlZFxuICAgICAgaWYgKGdhbWVTdGF0ZS5zdGFydGVkKSB7XG4gICAgICAgIC8vIE1hcmsgZ2FtZSBhcyBmaW5pc2hlZFxuICAgICAgICBhd2FpdCB1cGRhdGVEb2MoZ2FtZVJlZiwge1xuICAgICAgICAgIHN0YXR1czogJ2ZpbmlzaGVkJyxcbiAgICAgICAgICAnX190cmVuZGd1ZXNzZXIuc3RhdGUnOiB7XG4gICAgICAgICAgICAuLi5nYW1lU3RhdGUsXG4gICAgICAgICAgICBmaW5pc2hlZDogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgaGlnaCBzY29yZSBpZiBuZWVkZWRcbiAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVIaWdoU2NvcmUocGxheWVyVWlkLCBnYW1lU3RhdGUuY2F0ZWdvcnksIGZpbmFsU2NvcmUpO1xuICAgICAgfVxuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGVuZGluZyBnYW1lOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gQ3JlYXRlIGEgbmV3IGdhbWUgc2Vzc2lvblxuICBzdGF0aWMgYXN5bmMgY3JlYXRlR2FtZShjcmVhdGVkQnk6IHN0cmluZywgcGxheWVyTmFtZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgLy8gR2VuZXJhdGUgYSBzaG9ydCA2LWNoYXJhY3RlciBnYW1lIElEICh1cHBlcmNhc2UpXG4gICAgICBjb25zdCBnYW1lSWQgPSB0aGlzLmdlbmVyYXRlR2FtZUlkKCk7XG4gICAgICBcbiAgICAgIGlmIChVU0VfTU9DS19EQVRBKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdVc2luZyBtb2NrIGRhdGEgZm9yIGdhbWUgY3JlYXRpb24nKTtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBnYW1lIElEIHdpdGhvdXQgYWN0dWFsbHkgd3JpdGluZyB0byBGaXJlc3RvcmVcbiAgICAgICAgcmV0dXJuIGdhbWVJZDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZ2FtZVJlZiA9IGRvYyhkYiwgJ2dhbWVzJywgZ2FtZUlkKTtcbiAgICAgIFxuICAgICAgLy8gSW5pdGlhbGl6ZSBwbGF5ZXIgZGF0YVxuICAgICAgY29uc3QgcGxheWVyRGF0YTogVHJlbmRHdWVzc2VyUGxheWVyID0ge1xuICAgICAgICB1aWQ6IGNyZWF0ZWRCeSxcbiAgICAgICAgbmFtZTogcGxheWVyTmFtZSB8fCAnUGxheWVyJyxcbiAgICAgICAgc2NvcmU6IDBcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIEluaXRpYWwgZ2FtZSBkYXRhXG4gICAgICBjb25zdCBnYW1lRGF0YSA9IHtcbiAgICAgICAgaWQ6IGdhbWVJZCxcbiAgICAgICAgY3JlYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSxcbiAgICAgICAgY3JlYXRlZEJ5LFxuICAgICAgICBnYW1lVHlwZTogJ3RyZW5kZ3Vlc3NlcicsXG4gICAgICAgIHN0YXR1czogJ3dhaXRpbmcnLFxuICAgICAgICBbY3JlYXRlZEJ5XTogcGxheWVyRGF0YVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgYXdhaXQgc2V0RG9jKGdhbWVSZWYsIGdhbWVEYXRhKTtcbiAgICAgIHJldHVybiBnYW1lSWQ7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgZ2FtZTonLCBlcnJvcik7XG4gICAgICBcbiAgICAgIGlmIChVU0VfTU9DS19EQVRBKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGYWxsaW5nIGJhY2sgdG8gbW9jayBkYXRhIGR1ZSB0byBlcnJvcicpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUdhbWVJZCgpO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEZldGNoIGxlYWRlcmJvYXJkIGZvciBhIGNhdGVnb3J5XG4gIHN0YXRpYyBhc3luYyBnZXRMZWFkZXJib2FyZChjYXRlZ29yeTogU2VhcmNoQ2F0ZWdvcnkpOiBQcm9taXNlPFRyZW5kR3Vlc3NlclBsYXllcltdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGxlYWRlcmJvYXJkUmVmID0gY29sbGVjdGlvbihkYiwgJ2xlYWRlcmJvYXJkJyk7XG4gICAgICBjb25zdCBxID0gcXVlcnkoXG4gICAgICAgIGxlYWRlcmJvYXJkUmVmLFxuICAgICAgICB3aGVyZSgnY2F0ZWdvcnknLCAnPT0nLCBjYXRlZ29yeSksXG4gICAgICAgIG9yZGVyQnkoJ3Njb3JlJywgJ2Rlc2MnKSxcbiAgICAgICAgbGltaXQoMTApXG4gICAgICApO1xuICAgICAgXG4gICAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhxKTtcbiAgICAgIGNvbnN0IGxlYWRlcmJvYXJkOiBUcmVuZEd1ZXNzZXJQbGF5ZXJbXSA9IFtdO1xuICAgICAgXG4gICAgICBxdWVyeVNuYXBzaG90LmZvckVhY2goKGRvYykgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0gZG9jLmRhdGEoKTtcbiAgICAgICAgbGVhZGVyYm9hcmQucHVzaCh7XG4gICAgICAgICAgdWlkOiBkYXRhLnVpZCxcbiAgICAgICAgICBuYW1lOiBkYXRhLm5hbWUsXG4gICAgICAgICAgc2NvcmU6IGRhdGEuc2NvcmUsXG4gICAgICAgICAgaGlnaFNjb3JlczogZGF0YS5oaWdoU2NvcmVzXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiBsZWFkZXJib2FyZDtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBsZWFkZXJib2FyZDonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEhlbHBlciBtZXRob2RzXG4gIHByaXZhdGUgc3RhdGljIGFzeW5jIHVwZGF0ZUhpZ2hTY29yZShcbiAgICBwbGF5ZXJVaWQ6IHN0cmluZywgXG4gICAgY2F0ZWdvcnk6IFNlYXJjaENhdGVnb3J5LCBcbiAgICBzY29yZTogbnVtYmVyXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwbGF5ZXJSZWYgPSBkb2MoZGIsICdwbGF5ZXJzJywgcGxheWVyVWlkKTtcbiAgICAgIGNvbnN0IHBsYXllckRvYyA9IGF3YWl0IGdldERvYyhwbGF5ZXJSZWYpO1xuICAgICAgXG4gICAgICBpZiAocGxheWVyRG9jLmV4aXN0cygpKSB7XG4gICAgICAgIGNvbnN0IHBsYXllckRhdGEgPSBwbGF5ZXJEb2MuZGF0YSgpO1xuICAgICAgICBjb25zdCBjdXJyZW50SGlnaFNjb3JlID0gcGxheWVyRGF0YS5oaWdoU2NvcmVzPy5bY2F0ZWdvcnldIHx8IDA7XG4gICAgICAgIFxuICAgICAgICBpZiAoc2NvcmUgPiBjdXJyZW50SGlnaFNjb3JlKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIHBsYXllcidzIGhpZ2ggc2NvcmUgZm9yIHRoaXMgY2F0ZWdvcnlcbiAgICAgICAgICBhd2FpdCB1cGRhdGVEb2MocGxheWVyUmVmLCB7XG4gICAgICAgICAgICBbYGhpZ2hTY29yZXMuJHtjYXRlZ29yeX1gXTogc2NvcmVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBbHNvIHVwZGF0ZSBsZWFkZXJib2FyZCBpZiBzY29yZSBpcyBzaWduaWZpY2FudFxuICAgICAgICAgIGlmIChzY29yZSA+IDUpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlYWRlcmJvYXJkUmVmID0gZG9jKGRiLCAnbGVhZGVyYm9hcmQnLCBgJHtjYXRlZ29yeX1fJHtwbGF5ZXJVaWR9YCk7XG4gICAgICAgICAgICBhd2FpdCBzZXREb2MobGVhZGVyYm9hcmRSZWYsIHtcbiAgICAgICAgICAgICAgdWlkOiBwbGF5ZXJVaWQsXG4gICAgICAgICAgICAgIG5hbWU6IHBsYXllckRhdGEubmFtZSB8fCAnVW5rbm93biBQbGF5ZXInLFxuICAgICAgICAgICAgICBzY29yZSxcbiAgICAgICAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgICAgICAgIHVwZGF0ZWRBdDogc2VydmVyVGltZXN0YW1wKClcbiAgICAgICAgICAgIH0sIHsgbWVyZ2U6IHRydWUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgaGlnaCBzY29yZTonLCBlcnJvcik7XG4gICAgICAvLyBEb24ndCB0aHJvdywganVzdCBsb2cgLSB0aGlzIGlzIGEgbm9uLWNyaXRpY2FsIG9wZXJhdGlvblxuICAgIH1cbiAgfVxuICBcbiAgcHJpdmF0ZSBzdGF0aWMgYXN5bmMgZmV0Y2hUZXJtc0J5Q2F0ZWdvcnkoY2F0ZWdvcnk6IFNlYXJjaENhdGVnb3J5KTogUHJvbWlzZTxTZWFyY2hUZXJtW10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdGVybXNSZWYgPSBjb2xsZWN0aW9uKGRiLCAnc2VhcmNoVGVybXMnKTtcbiAgICAgIGxldCBxO1xuICAgICAgXG4gICAgICBpZiAoY2F0ZWdvcnkgPT09ICdldmVyeXRoaW5nJykge1xuICAgICAgICAvLyBGb3IgXCJldmVyeXRoaW5nXCIgY2F0ZWdvcnksIGdldCBhIG1peCBvZiBhbGwgY2F0ZWdvcmllc1xuICAgICAgICBxID0gcXVlcnkodGVybXNSZWYsIGxpbWl0KDUwKSk7XG4gICAgICB9IGVsc2UgaWYgKGNhdGVnb3J5ID09PSAnbGF0ZXN0Jykge1xuICAgICAgICAvLyBGb3IgXCJsYXRlc3RcIiwgZ2V0IHRoZSBtb3N0IHJlY2VudGx5IGFkZGVkIHRlcm1zXG4gICAgICAgIHEgPSBxdWVyeSh0ZXJtc1JlZiwgb3JkZXJCeSgndGltZXN0YW1wJywgJ2Rlc2MnKSwgbGltaXQoNTApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBzcGVjaWZpYyBjYXRlZ29yaWVzXG4gICAgICAgIHEgPSBxdWVyeSh0ZXJtc1JlZiwgd2hlcmUoJ2NhdGVnb3J5JywgJz09JywgY2F0ZWdvcnkpLCBsaW1pdCg1MCkpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhxKTtcbiAgICAgIGNvbnN0IHRlcm1zOiBTZWFyY2hUZXJtW10gPSBbXTtcbiAgICAgIFxuICAgICAgcXVlcnlTbmFwc2hvdC5mb3JFYWNoKChkb2MpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGRvYy5kYXRhKCkgYXMgU2VhcmNoVGVybTtcbiAgICAgICAgdGVybXMucHVzaCh7XG4gICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICBpZDogZG9jLmlkXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiB0ZXJtcztcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB0ZXJtczonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIHByaXZhdGUgc3RhdGljIGFzeW5jIGZldGNoQ3VzdG9tVGVybVdpdGhSZWxhdGVkKGN1c3RvbVRlcm06IHN0cmluZyk6IFByb21pc2U8U2VhcmNoVGVybVtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoaXMgd291bGQgdHlwaWNhbGx5IGNhbGwgYSBGaXJlYmFzZSBGdW5jdGlvbiB0byBnZXQgdGhlIGN1c3RvbSB0ZXJtIGRhdGFcbiAgICAgIC8vIEZvciBub3csIHdlJ2xsIHNpbXVsYXRlIGl0IHdpdGggYSBwbGFjZWhvbGRlclxuICAgICAgXG4gICAgICAvLyBGaXJzdCB0ZXJtIHdpbGwgYmUgdGhlIGN1c3RvbSBvbmVcbiAgICAgIGNvbnN0IGN1c3RvbVNlYXJjaFRlcm06IFNlYXJjaFRlcm0gPSB7XG4gICAgICAgIGlkOiB1dWlkdjQoKSxcbiAgICAgICAgdGVybTogY3VzdG9tVGVybSxcbiAgICAgICAgdm9sdW1lOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDApICsgMSwgLy8gUGxhY2Vob2xkZXIgdm9sdW1lXG4gICAgICAgIGNhdGVnb3J5OiAnY3VzdG9tJyxcbiAgICAgICAgaW1hZ2VVcmw6IGBodHRwczovL3NvdXJjZS51bnNwbGFzaC5jb20vZmVhdHVyZWQvPyR7ZW5jb2RlVVJJQ29tcG9uZW50KGN1c3RvbVRlcm0pfWAsXG4gICAgICAgIHRpbWVzdGFtcDogVGltZXN0YW1wLm5vdygpXG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBUaGVuIGdldCBzb21lIHJlbGF0ZWQgdGVybXMgZnJvbSB0aGUgZGF0YWJhc2UgKHJhbmRvbSBmb3Igbm93KVxuICAgICAgY29uc3QgdGVybXNSZWYgPSBjb2xsZWN0aW9uKGRiLCAnc2VhcmNoVGVybXMnKTtcbiAgICAgIGNvbnN0IHEgPSBxdWVyeSh0ZXJtc1JlZiwgbGltaXQoMjApKTtcbiAgICAgIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpO1xuICAgICAgXG4gICAgICBjb25zdCB0ZXJtczogU2VhcmNoVGVybVtdID0gW2N1c3RvbVNlYXJjaFRlcm1dO1xuICAgICAgXG4gICAgICBxdWVyeVNuYXBzaG90LmZvckVhY2goKGRvYykgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0gZG9jLmRhdGEoKSBhcyBTZWFyY2hUZXJtO1xuICAgICAgICB0ZXJtcy5wdXNoKHtcbiAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgIGlkOiBkb2MuaWRcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHRlcm1zO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGN1c3RvbSB0ZXJtOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgcHJpdmF0ZSBzdGF0aWMgc2h1ZmZsZVRlcm1zKHRlcm1zOiBTZWFyY2hUZXJtW10pOiBTZWFyY2hUZXJtW10ge1xuICAgIGNvbnN0IHNodWZmbGVkID0gWy4uLnRlcm1zXTtcbiAgICBmb3IgKGxldCBpID0gc2h1ZmZsZWQubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgY29uc3QgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xuICAgICAgW3NodWZmbGVkW2ldLCBzaHVmZmxlZFtqXV0gPSBbc2h1ZmZsZWRbal0sIHNodWZmbGVkW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHNodWZmbGVkO1xuICB9XG4gIFxuICBwcml2YXRlIHN0YXRpYyBnZW5lcmF0ZUdhbWVJZCgpOiBzdHJpbmcge1xuICAgIC8vIEdlbmVyYXRlIGEgNi1jaGFyYWN0ZXIgYWxwaGFudW1lcmljIGNvZGUgKHVwcGVyY2FzZSlcbiAgICBjb25zdCBjaGFycyA9ICdBQkNERUZHSEpLTE1OUFFSU1RVVldYWVoyMzQ1Njc4OSc7IC8vIFJlbW92ZWQgY29uZnVzYWJsZSBjaGFyYWN0ZXJzXG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICByZXN1bHQgKz0gY2hhcnMuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJzLmxlbmd0aCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59Il0sIm5hbWVzIjpbImRvYyIsInNldERvYyIsInVwZGF0ZURvYyIsImdldERvYyIsImNvbGxlY3Rpb24iLCJxdWVyeSIsIndoZXJlIiwiZ2V0RG9jcyIsIlRpbWVzdGFtcCIsInNlcnZlclRpbWVzdGFtcCIsImxpbWl0Iiwib3JkZXJCeSIsImRiIiwidjQiLCJ1dWlkdjQiLCJVU0VfTU9DS19EQVRBIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1VTRV9NT0NLX0RBVEEiLCJUcmVuZEd1ZXNzZXJTZXJ2aWNlIiwic3RhcnRHYW1lIiwiZ2FtZUlkIiwiY2F0ZWdvcnkiLCJjdXN0b21UZXJtIiwiZ2FtZVJlZiIsInRvVXBwZXJDYXNlIiwiZ2FtZURvYyIsImV4aXN0cyIsIkVycm9yIiwidGVybXMiLCJmZXRjaEN1c3RvbVRlcm1XaXRoUmVsYXRlZCIsImZldGNoVGVybXNCeUNhdGVnb3J5IiwibGVuZ3RoIiwic2h1ZmZsZWRUZXJtcyIsInNodWZmbGVUZXJtcyIsImdhbWVTdGF0ZSIsImN1cnJlbnRSb3VuZCIsImtub3duVGVybSIsImhpZGRlblRlcm0iLCJzdGFydGVkIiwiZmluaXNoZWQiLCJ1c2VkVGVybXMiLCJpZCIsInNsaWNlIiwidW5kZWZpbmVkIiwic3RhdHVzIiwiZXJyb3IiLCJjb25zb2xlIiwibWFrZUd1ZXNzIiwicGxheWVyVWlkIiwiaXNIaWdoZXIiLCJnYW1lRGF0YSIsImRhdGEiLCJwbGF5ZXIiLCJpc0NvcnJlY3QiLCJ2b2x1bWUiLCJuZXh0Um91bmQiLCJuZXdQbGF5ZXJTY29yZSIsInNjb3JlIiwibmV4dFRlcm0iLCJyZW1haW5pbmdUZXJtcyIsInVwZGF0ZWRTdGF0ZSIsIndpbm5lciIsInVwZGF0ZUhpZ2hTY29yZSIsImVuZEdhbWUiLCJmaW5hbFNjb3JlIiwiY3JlYXRlR2FtZSIsImNyZWF0ZWRCeSIsInBsYXllck5hbWUiLCJnZW5lcmF0ZUdhbWVJZCIsImxvZyIsInBsYXllckRhdGEiLCJ1aWQiLCJuYW1lIiwiY3JlYXRlZEF0IiwiZ2FtZVR5cGUiLCJnZXRMZWFkZXJib2FyZCIsImxlYWRlcmJvYXJkUmVmIiwicSIsInF1ZXJ5U25hcHNob3QiLCJsZWFkZXJib2FyZCIsImZvckVhY2giLCJwdXNoIiwiaGlnaFNjb3JlcyIsInBsYXllclJlZiIsInBsYXllckRvYyIsImN1cnJlbnRIaWdoU2NvcmUiLCJ1cGRhdGVkQXQiLCJtZXJnZSIsInRlcm1zUmVmIiwiY3VzdG9tU2VhcmNoVGVybSIsInRlcm0iLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJpbWFnZVVybCIsImVuY29kZVVSSUNvbXBvbmVudCIsInRpbWVzdGFtcCIsIm5vdyIsInNodWZmbGVkIiwiaSIsImoiLCJjaGFycyIsInJlc3VsdCIsImNoYXJBdCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/lib/firebase/trendGuesserService.ts\n"));

/***/ })

});