"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "(pages-dir-browser)/./src/lib/firebase/trendGuesserService.ts":
/*!*************************************************!*\
  !*** ./src/lib/firebase/trendGuesserService.ts ***!
  \*************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TrendGuesserService: () => (/* binding */ TrendGuesserService)\n/* harmony export */ });\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/firestore */ \"(pages-dir-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./firebase */ \"(pages-dir-browser)/./src/lib/firebase/firebase.ts\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uuid */ \"(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/index.js\");\n/* harmony import */ var _mockData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mockData */ \"(pages-dir-browser)/./src/lib/firebase/mockData.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// src/lib/firebase/trendGuesserService.ts\n\n\n\n\n// Development mode flag\nconst USE_MOCK_DATA = process.env.NEXT_PUBLIC_USE_MOCK_DATA === 'true' || \"development\" === 'development';\nclass TrendGuesserService {\n    // Start a new game with selected category\n    static async startGame(gameId, category, customTerm) {\n        try {\n            // In mock mode, we don't need to check if the game exists\n            if (!USE_MOCK_DATA) {\n                const gameRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'games', gameId.toUpperCase());\n                const gameDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(gameRef);\n                if (!gameDoc.exists()) {\n                    throw new Error('Game does not exist');\n                }\n            } else {\n                console.log('Using mock data for game start');\n            }\n            // Get terms for the selected category\n            let terms = [];\n            if (category === 'custom' && customTerm) {\n                // For custom games, fetch the custom term and related terms\n                terms = await this.fetchCustomTermWithRelated(customTerm);\n            } else {\n                // For predefined categories, fetch terms from the database\n                terms = await this.fetchTermsByCategory(category);\n            }\n            if (terms.length < 2) {\n                throw new Error('Not enough terms available');\n            }\n            // Shuffle the terms\n            const shuffledTerms = this.shuffleTerms(terms);\n            // Initialize game state with first two terms\n            const gameState = {\n                currentRound: 1,\n                knownTerm: shuffledTerms[0],\n                hiddenTerm: shuffledTerms[1],\n                category,\n                started: true,\n                finished: false,\n                usedTerms: [\n                    shuffledTerms[0].id,\n                    shuffledTerms[1].id\n                ],\n                terms: shuffledTerms.slice(2),\n                customTerm: category === 'custom' ? customTerm : undefined\n            };\n            if (!USE_MOCK_DATA) {\n                // Update the game document with new game state\n                const gameRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'games', gameId.toUpperCase());\n                await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(gameRef, {\n                    status: 'active',\n                    '__trendguesser.state': gameState\n                });\n            } else {\n                // In mock mode, we just log what would have happened\n                console.log('Mock: Game started with category:', category);\n                // Store the game state in sessionStorage for mock mode\n                if (true) {\n                    sessionStorage.setItem(\"game_\".concat(gameId), JSON.stringify({\n                        status: 'active',\n                        '__trendguesser.state': gameState,\n                        [sessionStorage.getItem('mock_user_uid') || 'mock_user']: {\n                            uid: sessionStorage.getItem('mock_user_uid') || 'mock_user',\n                            name: 'Mock Player',\n                            score: 0\n                        }\n                    }));\n                }\n            }\n        } catch (error) {\n            console.error('Error starting game:', error);\n            if (USE_MOCK_DATA) {\n                console.log('Falling back to mock game state due to error');\n                // Create a basic mock game state\n                return;\n            }\n            throw error;\n        }\n    }\n    // Make a guess (higher or lower)\n    static async makeGuess(gameId, playerUid, isHigher) {\n        try {\n            const gameRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'games', gameId.toUpperCase());\n            const gameDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(gameRef);\n            if (!gameDoc.exists()) {\n                throw new Error('Game does not exist');\n            }\n            const gameData = gameDoc.data();\n            const gameState = gameData['__trendguesser.state'];\n            const player = gameData[playerUid];\n            if (!gameState || !gameState.started || gameState.finished) {\n                throw new Error('Game is not active');\n            }\n            // Check if the guess is correct\n            const isCorrect = isHigher ? gameState.hiddenTerm.volume > gameState.knownTerm.volume : gameState.hiddenTerm.volume < gameState.knownTerm.volume;\n            if (isCorrect) {\n                // Correct guess - prepare next round\n                const nextRound = gameState.currentRound + 1;\n                const newPlayerScore = (player.score || 0) + 1;\n                // Update player score\n                await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(gameRef, {\n                    [\"\".concat(playerUid, \".score\")]: newPlayerScore\n                });\n                // If we have more terms, set up next round\n                if (gameState.terms.length > 0) {\n                    const nextTerm = gameState.terms[0];\n                    const remainingTerms = gameState.terms.slice(1);\n                    const updatedState = {\n                        ...gameState,\n                        currentRound: nextRound,\n                        knownTerm: gameState.hiddenTerm,\n                        hiddenTerm: nextTerm,\n                        usedTerms: [\n                            ...gameState.usedTerms,\n                            nextTerm.id\n                        ],\n                        terms: remainingTerms\n                    };\n                    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(gameRef, {\n                        '__trendguesser.state': updatedState\n                    });\n                } else {\n                    // No more terms - player wins by completing all terms\n                    const updatedState = {\n                        ...gameState,\n                        finished: true,\n                        winner: playerUid\n                    };\n                    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(gameRef, {\n                        '__trendguesser.state': updatedState,\n                        status: 'finished'\n                    });\n                    // Update high score if needed\n                    await this.updateHighScore(playerUid, gameState.category, newPlayerScore);\n                }\n                return true;\n            } else {\n                // Incorrect guess - game over\n                const updatedState = {\n                    ...gameState,\n                    finished: true\n                };\n                await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(gameRef, {\n                    '__trendguesser.state': updatedState,\n                    status: 'finished'\n                });\n                // Update high score if needed\n                await this.updateHighScore(playerUid, gameState.category, player.score || 0);\n                return false;\n            }\n        } catch (error) {\n            console.error('Error making guess:', error);\n            throw error;\n        }\n    }\n    // End the game and update high scores\n    static async endGame(gameId, playerUid, finalScore) {\n        try {\n            const gameRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'games', gameId.toUpperCase());\n            const gameDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(gameRef);\n            if (!gameDoc.exists()) {\n                throw new Error('Game does not exist');\n            }\n            const gameData = gameDoc.data();\n            const gameState = gameData['__trendguesser.state'];\n            if (!gameState) {\n                throw new Error('No game state found');\n            }\n            // Only update if game was actually started\n            if (gameState.started) {\n                // Mark game as finished\n                await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(gameRef, {\n                    status: 'finished',\n                    '__trendguesser.state': {\n                        ...gameState,\n                        finished: true\n                    }\n                });\n                // Update high score if needed\n                await this.updateHighScore(playerUid, gameState.category, finalScore);\n            }\n        } catch (error) {\n            console.error('Error ending game:', error);\n            throw error;\n        }\n    }\n    // Create a new game session\n    static async createGame(createdBy, playerName) {\n        try {\n            // Generate a short 6-character game ID (uppercase)\n            const gameId = this.generateGameId();\n            if (USE_MOCK_DATA) {\n                console.log('Using mock data for game creation');\n                // Return the game ID without actually writing to Firestore\n                return gameId;\n            }\n            const gameRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'games', gameId);\n            // Initialize player data\n            const playerData = {\n                uid: createdBy,\n                name: playerName || 'Player',\n                score: 0\n            };\n            // Initial game data\n            const gameData = {\n                id: gameId,\n                createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n                createdBy,\n                gameType: 'trendguesser',\n                status: 'waiting',\n                [createdBy]: playerData\n            };\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setDoc)(gameRef, gameData);\n            return gameId;\n        } catch (error) {\n            console.error('Error creating game:', error);\n            if (USE_MOCK_DATA) {\n                console.log('Falling back to mock data due to error');\n                return this.generateGameId();\n            }\n            throw error;\n        }\n    }\n    // Fetch leaderboard for a category\n    static async getLeaderboard(category) {\n        try {\n            if (USE_MOCK_DATA) {\n                console.log('Using mock data for leaderboard');\n                // Sort and filter the mock leaderboard based on the requested category\n                return _mockData__WEBPACK_IMPORTED_MODULE_2__.sampleLeaderboard.filter((player)=>player.highScores && player.highScores[category]).sort((a, b)=>{\n                    var _a_highScores, _b_highScores;\n                    const scoreA = ((_a_highScores = a.highScores) === null || _a_highScores === void 0 ? void 0 : _a_highScores[category]) || 0;\n                    const scoreB = ((_b_highScores = b.highScores) === null || _b_highScores === void 0 ? void 0 : _b_highScores[category]) || 0;\n                    return scoreB - scoreA;\n                }).slice(0, 10);\n            }\n            const leaderboardRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'leaderboard');\n            const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(leaderboardRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('category', '==', category), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)('score', 'desc'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.limit)(10));\n            const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n            const leaderboard = [];\n            querySnapshot.forEach((doc)=>{\n                const data = doc.data();\n                leaderboard.push({\n                    uid: data.uid,\n                    name: data.name,\n                    score: data.score,\n                    highScores: data.highScores\n                });\n            });\n            return leaderboard;\n        } catch (error) {\n            console.error('Error fetching leaderboard:', error);\n            if (USE_MOCK_DATA) {\n                console.log('Falling back to mock data due to error');\n                return _mockData__WEBPACK_IMPORTED_MODULE_2__.sampleLeaderboard.slice(0, 10);\n            }\n            throw error;\n        }\n    }\n    // Helper methods\n    static async updateHighScore(playerUid, category, score) {\n        try {\n            const playerRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'players', playerUid);\n            const playerDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(playerRef);\n            if (playerDoc.exists()) {\n                var _playerData_highScores;\n                const playerData = playerDoc.data();\n                const currentHighScore = ((_playerData_highScores = playerData.highScores) === null || _playerData_highScores === void 0 ? void 0 : _playerData_highScores[category]) || 0;\n                if (score > currentHighScore) {\n                    // Update player's high score for this category\n                    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(playerRef, {\n                        [\"highScores.\".concat(category)]: score\n                    });\n                    // Also update leaderboard if score is significant\n                    if (score > 5) {\n                        const leaderboardRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'leaderboard', \"\".concat(category, \"_\").concat(playerUid));\n                        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setDoc)(leaderboardRef, {\n                            uid: playerUid,\n                            name: playerData.name || 'Unknown Player',\n                            score,\n                            category,\n                            updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)()\n                        }, {\n                            merge: true\n                        });\n                    }\n                }\n            }\n        } catch (error) {\n            console.error('Error updating high score:', error);\n        // Don't throw, just log - this is a non-critical operation\n        }\n    }\n    static async fetchTermsByCategory(category) {\n        try {\n            if (USE_MOCK_DATA) {\n                console.log('Using mock data for search terms');\n                if (category === 'everything') {\n                    // Return all sample terms\n                    return _mockData__WEBPACK_IMPORTED_MODULE_2__.sampleSearchTerms;\n                } else if (category === 'latest') {\n                    // Return terms sorted by timestamp\n                    return [\n                        ..._mockData__WEBPACK_IMPORTED_MODULE_2__.sampleSearchTerms\n                    ].sort(()=>Math.random() - 0.5);\n                } else {\n                    // Filter by category\n                    const filteredTerms = _mockData__WEBPACK_IMPORTED_MODULE_2__.sampleSearchTerms.filter((term)=>term.category === category);\n                    return filteredTerms.length > 0 ? filteredTerms : _mockData__WEBPACK_IMPORTED_MODULE_2__.sampleSearchTerms;\n                }\n            }\n            const termsRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'searchTerms');\n            let q;\n            if (category === 'everything') {\n                // For \"everything\" category, get a mix of all categories\n                q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(termsRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.limit)(50));\n            } else if (category === 'latest') {\n                // For \"latest\", get the most recently added terms\n                q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(termsRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)('timestamp', 'desc'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.limit)(50));\n            } else {\n                // For specific categories\n                q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(termsRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('category', '==', category), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.limit)(50));\n            }\n            const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n            const terms = [];\n            querySnapshot.forEach((doc)=>{\n                const data = doc.data();\n                terms.push({\n                    ...data,\n                    id: doc.id\n                });\n            });\n            return terms;\n        } catch (error) {\n            console.error('Error fetching terms:', error);\n            if (USE_MOCK_DATA) {\n                console.log('Falling back to mock data due to error');\n                return _mockData__WEBPACK_IMPORTED_MODULE_2__.sampleSearchTerms;\n            }\n            throw error;\n        }\n    }\n    static async fetchCustomTermWithRelated(customTerm) {\n        try {\n            // This would typically call a Firebase Function to get the custom term data\n            // For now, we'll simulate it with a placeholder\n            // First term will be the custom one\n            const customSearchTerm = {\n                id: (0,uuid__WEBPACK_IMPORTED_MODULE_3__.v4)(),\n                term: customTerm,\n                volume: Math.floor(Math.random() * 100) + 1,\n                category: 'custom',\n                imageUrl: \"https://source.unsplash.com/featured/?\".concat(encodeURIComponent(customTerm)),\n                timestamp: firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.Timestamp.now()\n            };\n            // Then get some related terms from the database (random for now)\n            const termsRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'searchTerms');\n            const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(termsRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.limit)(20));\n            const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n            const terms = [\n                customSearchTerm\n            ];\n            querySnapshot.forEach((doc)=>{\n                const data = doc.data();\n                terms.push({\n                    ...data,\n                    id: doc.id\n                });\n            });\n            return terms;\n        } catch (error) {\n            console.error('Error fetching custom term:', error);\n            throw error;\n        }\n    }\n    static shuffleTerms(terms) {\n        const shuffled = [\n            ...terms\n        ];\n        for(let i = shuffled.length - 1; i > 0; i--){\n            const j = Math.floor(Math.random() * (i + 1));\n            [shuffled[i], shuffled[j]] = [\n                shuffled[j],\n                shuffled[i]\n            ];\n        }\n        return shuffled;\n    }\n    static generateGameId() {\n        // Generate a 6-character alphanumeric code (uppercase)\n        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Removed confusable characters\n        let result = '';\n        for(let i = 0; i < 6; i++){\n            result += chars.charAt(Math.floor(Math.random() * chars.length));\n        }\n        return result;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9saWIvZmlyZWJhc2UvdHJlbmRHdWVzc2VyU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSwwQ0FBMEM7QUFnQmQ7QUFDSTtBQUNJO0FBRThCO0FBRWxFLHdCQUF3QjtBQUN4QixNQUFNaUIsZ0JBQWdCQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLHlCQUF5QixLQUFLLFVBQ3pDRixrQkFBeUI7QUFFekMsTUFBTUc7SUFDWCwwQ0FBMEM7SUFDMUMsYUFBYUMsVUFBVUMsTUFBYyxFQUFFQyxRQUF3QixFQUFFQyxVQUFtQixFQUFpQjtRQUNuRyxJQUFJO1lBQ0YsMERBQTBEO1lBQzFELElBQUksQ0FBQ1IsZUFBZTtnQkFDbEIsTUFBTVMsVUFBVTFCLHVEQUFHQSxDQUFDWSx5Q0FBRUEsRUFBRSxTQUFTVyxPQUFPSSxXQUFXO2dCQUNuRCxNQUFNQyxVQUFVLE1BQU16QiwwREFBTUEsQ0FBQ3VCO2dCQUU3QixJQUFJLENBQUNFLFFBQVFDLE1BQU0sSUFBSTtvQkFDckIsTUFBTSxJQUFJQyxNQUFNO2dCQUNsQjtZQUNGLE9BQU87Z0JBQ0xDLFFBQVFDLEdBQUcsQ0FBQztZQUNkO1lBRUEsc0NBQXNDO1lBQ3RDLElBQUlDLFFBQXNCLEVBQUU7WUFFNUIsSUFBSVQsYUFBYSxZQUFZQyxZQUFZO2dCQUN2Qyw0REFBNEQ7Z0JBQzVEUSxRQUFRLE1BQU0sSUFBSSxDQUFDQywwQkFBMEIsQ0FBQ1Q7WUFDaEQsT0FBTztnQkFDTCwyREFBMkQ7Z0JBQzNEUSxRQUFRLE1BQU0sSUFBSSxDQUFDRSxvQkFBb0IsQ0FBQ1g7WUFDMUM7WUFFQSxJQUFJUyxNQUFNRyxNQUFNLEdBQUcsR0FBRztnQkFDcEIsTUFBTSxJQUFJTixNQUFNO1lBQ2xCO1lBRUEsb0JBQW9CO1lBQ3BCLE1BQU1PLGdCQUFnQixJQUFJLENBQUNDLFlBQVksQ0FBQ0w7WUFFeEMsNkNBQTZDO1lBQzdDLE1BQU1NLFlBQW1DO2dCQUN2Q0MsY0FBYztnQkFD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RCxNQUFNRSxNQUFNLENBQUNoQixLQUFLTSxLQUFLLENBQUNOLEtBQUtDLE1BQU0sS0FBS2EsTUFBTWhGLE1BQU07UUFDaEU7UUFDQSxPQUFPaUY7SUFDVDtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvYWxleC9EZXZlbG9wZXIvdHJlbmRndWVzc2VyL3NyYy9saWIvZmlyZWJhc2UvdHJlbmRHdWVzc2VyU2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvbGliL2ZpcmViYXNlL3RyZW5kR3Vlc3NlclNlcnZpY2UudHNcbmltcG9ydCB7IFxuICBkb2MsIFxuICBzZXREb2MsIFxuICB1cGRhdGVEb2MsIFxuICBnZXREb2MsIFxuICBjb2xsZWN0aW9uLCBcbiAgcXVlcnksIFxuICB3aGVyZSwgXG4gIGdldERvY3MsIFxuICBhcnJheVVuaW9uLCBcbiAgVGltZXN0YW1wLCBcbiAgc2VydmVyVGltZXN0YW1wLFxuICBpbmNyZW1lbnQsXG4gIGxpbWl0LFxuICBvcmRlckJ5XG59IGZyb20gJ2ZpcmViYXNlL2ZpcmVzdG9yZSc7XG5pbXBvcnQgeyBkYiB9IGZyb20gJy4vZmlyZWJhc2UnO1xuaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSAndXVpZCc7XG5pbXBvcnQgeyBTZWFyY2hDYXRlZ29yeSwgU2VhcmNoVGVybSwgVHJlbmRHdWVzc2VyR2FtZVN0YXRlLCBUcmVuZEd1ZXNzZXJQbGF5ZXIgfSBmcm9tICdAL3R5cGVzJztcbmltcG9ydCB7IHNhbXBsZVNlYXJjaFRlcm1zLCBzYW1wbGVMZWFkZXJib2FyZCB9IGZyb20gJy4vbW9ja0RhdGEnO1xuXG4vLyBEZXZlbG9wbWVudCBtb2RlIGZsYWdcbmNvbnN0IFVTRV9NT0NLX0RBVEEgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19VU0VfTU9DS19EQVRBID09PSAndHJ1ZScgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnO1xuXG5leHBvcnQgY2xhc3MgVHJlbmRHdWVzc2VyU2VydmljZSB7XG4gIC8vIFN0YXJ0IGEgbmV3IGdhbWUgd2l0aCBzZWxlY3RlZCBjYXRlZ29yeVxuICBzdGF0aWMgYXN5bmMgc3RhcnRHYW1lKGdhbWVJZDogc3RyaW5nLCBjYXRlZ29yeTogU2VhcmNoQ2F0ZWdvcnksIGN1c3RvbVRlcm0/OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgLy8gSW4gbW9jayBtb2RlLCB3ZSBkb24ndCBuZWVkIHRvIGNoZWNrIGlmIHRoZSBnYW1lIGV4aXN0c1xuICAgICAgaWYgKCFVU0VfTU9DS19EQVRBKSB7XG4gICAgICAgIGNvbnN0IGdhbWVSZWYgPSBkb2MoZGIsICdnYW1lcycsIGdhbWVJZC50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgY29uc3QgZ2FtZURvYyA9IGF3YWl0IGdldERvYyhnYW1lUmVmKTtcbiAgICAgICAgXG4gICAgICAgIGlmICghZ2FtZURvYy5leGlzdHMoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR2FtZSBkb2VzIG5vdCBleGlzdCcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnVXNpbmcgbW9jayBkYXRhIGZvciBnYW1lIHN0YXJ0Jyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEdldCB0ZXJtcyBmb3IgdGhlIHNlbGVjdGVkIGNhdGVnb3J5XG4gICAgICBsZXQgdGVybXM6IFNlYXJjaFRlcm1bXSA9IFtdO1xuICAgICAgXG4gICAgICBpZiAoY2F0ZWdvcnkgPT09ICdjdXN0b20nICYmIGN1c3RvbVRlcm0pIHtcbiAgICAgICAgLy8gRm9yIGN1c3RvbSBnYW1lcywgZmV0Y2ggdGhlIGN1c3RvbSB0ZXJtIGFuZCByZWxhdGVkIHRlcm1zXG4gICAgICAgIHRlcm1zID0gYXdhaXQgdGhpcy5mZXRjaEN1c3RvbVRlcm1XaXRoUmVsYXRlZChjdXN0b21UZXJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBwcmVkZWZpbmVkIGNhdGVnb3JpZXMsIGZldGNoIHRlcm1zIGZyb20gdGhlIGRhdGFiYXNlXG4gICAgICAgIHRlcm1zID0gYXdhaXQgdGhpcy5mZXRjaFRlcm1zQnlDYXRlZ29yeShjYXRlZ29yeSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICh0ZXJtcy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGVub3VnaCB0ZXJtcyBhdmFpbGFibGUnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2h1ZmZsZSB0aGUgdGVybXNcbiAgICAgIGNvbnN0IHNodWZmbGVkVGVybXMgPSB0aGlzLnNodWZmbGVUZXJtcyh0ZXJtcyk7XG4gICAgICBcbiAgICAgIC8vIEluaXRpYWxpemUgZ2FtZSBzdGF0ZSB3aXRoIGZpcnN0IHR3byB0ZXJtc1xuICAgICAgY29uc3QgZ2FtZVN0YXRlOiBUcmVuZEd1ZXNzZXJHYW1lU3RhdGUgPSB7XG4gICAgICAgIGN1cnJlbnRSb3VuZDogMSxcbiAgICAgICAga25vd25UZXJtOiBzaHVmZmxlZFRlcm1zWzBdLFxuICAgICAgICBoaWRkZW5UZXJtOiBzaHVmZmxlZFRlcm1zWzFdLFxuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgc3RhcnRlZDogdHJ1ZSxcbiAgICAgICAgZmluaXNoZWQ6IGZhbHNlLFxuICAgICAgICB1c2VkVGVybXM6IFtzaHVmZmxlZFRlcm1zWzBdLmlkLCBzaHVmZmxlZFRlcm1zWzFdLmlkXSxcbiAgICAgICAgdGVybXM6IHNodWZmbGVkVGVybXMuc2xpY2UoMiksIC8vIFN0b3JlIHJlbWFpbmluZyB0ZXJtc1xuICAgICAgICBjdXN0b21UZXJtOiBjYXRlZ29yeSA9PT0gJ2N1c3RvbScgPyBjdXN0b21UZXJtIDogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgICAgXG4gICAgICBpZiAoIVVTRV9NT0NLX0RBVEEpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBnYW1lIGRvY3VtZW50IHdpdGggbmV3IGdhbWUgc3RhdGVcbiAgICAgICAgY29uc3QgZ2FtZVJlZiA9IGRvYyhkYiwgJ2dhbWVzJywgZ2FtZUlkLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICBhd2FpdCB1cGRhdGVEb2MoZ2FtZVJlZiwge1xuICAgICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgICAgJ19fdHJlbmRndWVzc2VyLnN0YXRlJzogZ2FtZVN0YXRlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW4gbW9jayBtb2RlLCB3ZSBqdXN0IGxvZyB3aGF0IHdvdWxkIGhhdmUgaGFwcGVuZWRcbiAgICAgICAgY29uc29sZS5sb2coJ01vY2s6IEdhbWUgc3RhcnRlZCB3aXRoIGNhdGVnb3J5OicsIGNhdGVnb3J5KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0b3JlIHRoZSBnYW1lIHN0YXRlIGluIHNlc3Npb25TdG9yYWdlIGZvciBtb2NrIG1vZGVcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShgZ2FtZV8ke2dhbWVJZH1gLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBzdGF0dXM6ICdhY3RpdmUnLFxuICAgICAgICAgICAgJ19fdHJlbmRndWVzc2VyLnN0YXRlJzogZ2FtZVN0YXRlLFxuICAgICAgICAgICAgW3Nlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ21vY2tfdXNlcl91aWQnKSB8fCAnbW9ja191c2VyJ106IHtcbiAgICAgICAgICAgICAgdWlkOiBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCdtb2NrX3VzZXJfdWlkJykgfHwgJ21vY2tfdXNlcicsXG4gICAgICAgICAgICAgIG5hbWU6ICdNb2NrIFBsYXllcicsXG4gICAgICAgICAgICAgIHNjb3JlOiAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc3RhcnRpbmcgZ2FtZTonLCBlcnJvcik7XG4gICAgICBcbiAgICAgIGlmIChVU0VfTU9DS19EQVRBKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGYWxsaW5nIGJhY2sgdG8gbW9jayBnYW1lIHN0YXRlIGR1ZSB0byBlcnJvcicpO1xuICAgICAgICAvLyBDcmVhdGUgYSBiYXNpYyBtb2NrIGdhbWUgc3RhdGVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIE1ha2UgYSBndWVzcyAoaGlnaGVyIG9yIGxvd2VyKVxuICBzdGF0aWMgYXN5bmMgbWFrZUd1ZXNzKGdhbWVJZDogc3RyaW5nLCBwbGF5ZXJVaWQ6IHN0cmluZywgaXNIaWdoZXI6IGJvb2xlYW4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZ2FtZVJlZiA9IGRvYyhkYiwgJ2dhbWVzJywgZ2FtZUlkLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgY29uc3QgZ2FtZURvYyA9IGF3YWl0IGdldERvYyhnYW1lUmVmKTtcbiAgICAgIFxuICAgICAgaWYgKCFnYW1lRG9jLmV4aXN0cygpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignR2FtZSBkb2VzIG5vdCBleGlzdCcpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBnYW1lRGF0YSA9IGdhbWVEb2MuZGF0YSgpO1xuICAgICAgY29uc3QgZ2FtZVN0YXRlID0gZ2FtZURhdGFbJ19fdHJlbmRndWVzc2VyLnN0YXRlJ10gYXMgVHJlbmRHdWVzc2VyR2FtZVN0YXRlO1xuICAgICAgY29uc3QgcGxheWVyID0gZ2FtZURhdGFbcGxheWVyVWlkXSBhcyBUcmVuZEd1ZXNzZXJQbGF5ZXI7XG4gICAgICBcbiAgICAgIGlmICghZ2FtZVN0YXRlIHx8ICFnYW1lU3RhdGUuc3RhcnRlZCB8fCBnYW1lU3RhdGUuZmluaXNoZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHYW1lIGlzIG5vdCBhY3RpdmUnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGd1ZXNzIGlzIGNvcnJlY3RcbiAgICAgIGNvbnN0IGlzQ29ycmVjdCA9IGlzSGlnaGVyIFxuICAgICAgICA/IGdhbWVTdGF0ZS5oaWRkZW5UZXJtLnZvbHVtZSA+IGdhbWVTdGF0ZS5rbm93blRlcm0udm9sdW1lXG4gICAgICAgIDogZ2FtZVN0YXRlLmhpZGRlblRlcm0udm9sdW1lIDwgZ2FtZVN0YXRlLmtub3duVGVybS52b2x1bWU7XG4gICAgICBcbiAgICAgIGlmIChpc0NvcnJlY3QpIHtcbiAgICAgICAgLy8gQ29ycmVjdCBndWVzcyAtIHByZXBhcmUgbmV4dCByb3VuZFxuICAgICAgICBjb25zdCBuZXh0Um91bmQgPSBnYW1lU3RhdGUuY3VycmVudFJvdW5kICsgMTtcbiAgICAgICAgY29uc3QgbmV3UGxheWVyU2NvcmUgPSAocGxheWVyLnNjb3JlIHx8IDApICsgMTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBwbGF5ZXIgc2NvcmVcbiAgICAgICAgYXdhaXQgdXBkYXRlRG9jKGdhbWVSZWYsIHtcbiAgICAgICAgICBbYCR7cGxheWVyVWlkfS5zY29yZWBdOiBuZXdQbGF5ZXJTY29yZVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIElmIHdlIGhhdmUgbW9yZSB0ZXJtcywgc2V0IHVwIG5leHQgcm91bmRcbiAgICAgICAgaWYgKGdhbWVTdGF0ZS50ZXJtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgbmV4dFRlcm0gPSBnYW1lU3RhdGUudGVybXNbMF07XG4gICAgICAgICAgY29uc3QgcmVtYWluaW5nVGVybXMgPSBnYW1lU3RhdGUudGVybXMuc2xpY2UoMSk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgdXBkYXRlZFN0YXRlOiBUcmVuZEd1ZXNzZXJHYW1lU3RhdGUgPSB7XG4gICAgICAgICAgICAuLi5nYW1lU3RhdGUsXG4gICAgICAgICAgICBjdXJyZW50Um91bmQ6IG5leHRSb3VuZCxcbiAgICAgICAgICAgIGtub3duVGVybTogZ2FtZVN0YXRlLmhpZGRlblRlcm0sXG4gICAgICAgICAgICBoaWRkZW5UZXJtOiBuZXh0VGVybSxcbiAgICAgICAgICAgIHVzZWRUZXJtczogWy4uLmdhbWVTdGF0ZS51c2VkVGVybXMsIG5leHRUZXJtLmlkXSxcbiAgICAgICAgICAgIHRlcm1zOiByZW1haW5pbmdUZXJtc1xuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgYXdhaXQgdXBkYXRlRG9jKGdhbWVSZWYsIHtcbiAgICAgICAgICAgICdfX3RyZW5kZ3Vlc3Nlci5zdGF0ZSc6IHVwZGF0ZWRTdGF0ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vIG1vcmUgdGVybXMgLSBwbGF5ZXIgd2lucyBieSBjb21wbGV0aW5nIGFsbCB0ZXJtc1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRTdGF0ZTogVHJlbmRHdWVzc2VyR2FtZVN0YXRlID0ge1xuICAgICAgICAgICAgLi4uZ2FtZVN0YXRlLFxuICAgICAgICAgICAgZmluaXNoZWQ6IHRydWUsXG4gICAgICAgICAgICB3aW5uZXI6IHBsYXllclVpZFxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgYXdhaXQgdXBkYXRlRG9jKGdhbWVSZWYsIHtcbiAgICAgICAgICAgICdfX3RyZW5kZ3Vlc3Nlci5zdGF0ZSc6IHVwZGF0ZWRTdGF0ZSxcbiAgICAgICAgICAgIHN0YXR1czogJ2ZpbmlzaGVkJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFVwZGF0ZSBoaWdoIHNjb3JlIGlmIG5lZWRlZFxuICAgICAgICAgIGF3YWl0IHRoaXMudXBkYXRlSGlnaFNjb3JlKHBsYXllclVpZCwgZ2FtZVN0YXRlLmNhdGVnb3J5LCBuZXdQbGF5ZXJTY29yZSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW5jb3JyZWN0IGd1ZXNzIC0gZ2FtZSBvdmVyXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRTdGF0ZTogVHJlbmRHdWVzc2VyR2FtZVN0YXRlID0ge1xuICAgICAgICAgIC4uLmdhbWVTdGF0ZSxcbiAgICAgICAgICBmaW5pc2hlZDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgdXBkYXRlRG9jKGdhbWVSZWYsIHtcbiAgICAgICAgICAnX190cmVuZGd1ZXNzZXIuc3RhdGUnOiB1cGRhdGVkU3RhdGUsXG4gICAgICAgICAgc3RhdHVzOiAnZmluaXNoZWQnXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIGhpZ2ggc2NvcmUgaWYgbmVlZGVkXG4gICAgICAgIGF3YWl0IHRoaXMudXBkYXRlSGlnaFNjb3JlKHBsYXllclVpZCwgZ2FtZVN0YXRlLmNhdGVnb3J5LCBwbGF5ZXIuc2NvcmUgfHwgMCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbWFraW5nIGd1ZXNzOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gRW5kIHRoZSBnYW1lIGFuZCB1cGRhdGUgaGlnaCBzY29yZXNcbiAgc3RhdGljIGFzeW5jIGVuZEdhbWUoZ2FtZUlkOiBzdHJpbmcsIHBsYXllclVpZDogc3RyaW5nLCBmaW5hbFNjb3JlOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZ2FtZVJlZiA9IGRvYyhkYiwgJ2dhbWVzJywgZ2FtZUlkLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgY29uc3QgZ2FtZURvYyA9IGF3YWl0IGdldERvYyhnYW1lUmVmKTtcbiAgICAgIFxuICAgICAgaWYgKCFnYW1lRG9jLmV4aXN0cygpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignR2FtZSBkb2VzIG5vdCBleGlzdCcpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBnYW1lRGF0YSA9IGdhbWVEb2MuZGF0YSgpO1xuICAgICAgY29uc3QgZ2FtZVN0YXRlID0gZ2FtZURhdGFbJ19fdHJlbmRndWVzc2VyLnN0YXRlJ10gYXMgVHJlbmRHdWVzc2VyR2FtZVN0YXRlO1xuICAgICAgXG4gICAgICBpZiAoIWdhbWVTdGF0ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGdhbWUgc3RhdGUgZm91bmQnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gT25seSB1cGRhdGUgaWYgZ2FtZSB3YXMgYWN0dWFsbHkgc3RhcnRlZFxuICAgICAgaWYgKGdhbWVTdGF0ZS5zdGFydGVkKSB7XG4gICAgICAgIC8vIE1hcmsgZ2FtZSBhcyBmaW5pc2hlZFxuICAgICAgICBhd2FpdCB1cGRhdGVEb2MoZ2FtZVJlZiwge1xuICAgICAgICAgIHN0YXR1czogJ2ZpbmlzaGVkJyxcbiAgICAgICAgICAnX190cmVuZGd1ZXNzZXIuc3RhdGUnOiB7XG4gICAgICAgICAgICAuLi5nYW1lU3RhdGUsXG4gICAgICAgICAgICBmaW5pc2hlZDogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgaGlnaCBzY29yZSBpZiBuZWVkZWRcbiAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVIaWdoU2NvcmUocGxheWVyVWlkLCBnYW1lU3RhdGUuY2F0ZWdvcnksIGZpbmFsU2NvcmUpO1xuICAgICAgfVxuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGVuZGluZyBnYW1lOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gQ3JlYXRlIGEgbmV3IGdhbWUgc2Vzc2lvblxuICBzdGF0aWMgYXN5bmMgY3JlYXRlR2FtZShjcmVhdGVkQnk6IHN0cmluZywgcGxheWVyTmFtZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgLy8gR2VuZXJhdGUgYSBzaG9ydCA2LWNoYXJhY3RlciBnYW1lIElEICh1cHBlcmNhc2UpXG4gICAgICBjb25zdCBnYW1lSWQgPSB0aGlzLmdlbmVyYXRlR2FtZUlkKCk7XG4gICAgICBcbiAgICAgIGlmIChVU0VfTU9DS19EQVRBKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdVc2luZyBtb2NrIGRhdGEgZm9yIGdhbWUgY3JlYXRpb24nKTtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBnYW1lIElEIHdpdGhvdXQgYWN0dWFsbHkgd3JpdGluZyB0byBGaXJlc3RvcmVcbiAgICAgICAgcmV0dXJuIGdhbWVJZDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZ2FtZVJlZiA9IGRvYyhkYiwgJ2dhbWVzJywgZ2FtZUlkKTtcbiAgICAgIFxuICAgICAgLy8gSW5pdGlhbGl6ZSBwbGF5ZXIgZGF0YVxuICAgICAgY29uc3QgcGxheWVyRGF0YTogVHJlbmRHdWVzc2VyUGxheWVyID0ge1xuICAgICAgICB1aWQ6IGNyZWF0ZWRCeSxcbiAgICAgICAgbmFtZTogcGxheWVyTmFtZSB8fCAnUGxheWVyJyxcbiAgICAgICAgc2NvcmU6IDBcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIEluaXRpYWwgZ2FtZSBkYXRhXG4gICAgICBjb25zdCBnYW1lRGF0YSA9IHtcbiAgICAgICAgaWQ6IGdhbWVJZCxcbiAgICAgICAgY3JlYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSxcbiAgICAgICAgY3JlYXRlZEJ5LFxuICAgICAgICBnYW1lVHlwZTogJ3RyZW5kZ3Vlc3NlcicsXG4gICAgICAgIHN0YXR1czogJ3dhaXRpbmcnLFxuICAgICAgICBbY3JlYXRlZEJ5XTogcGxheWVyRGF0YVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgYXdhaXQgc2V0RG9jKGdhbWVSZWYsIGdhbWVEYXRhKTtcbiAgICAgIHJldHVybiBnYW1lSWQ7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgZ2FtZTonLCBlcnJvcik7XG4gICAgICBcbiAgICAgIGlmIChVU0VfTU9DS19EQVRBKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGYWxsaW5nIGJhY2sgdG8gbW9jayBkYXRhIGR1ZSB0byBlcnJvcicpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUdhbWVJZCgpO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEZldGNoIGxlYWRlcmJvYXJkIGZvciBhIGNhdGVnb3J5XG4gIHN0YXRpYyBhc3luYyBnZXRMZWFkZXJib2FyZChjYXRlZ29yeTogU2VhcmNoQ2F0ZWdvcnkpOiBQcm9taXNlPFRyZW5kR3Vlc3NlclBsYXllcltdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChVU0VfTU9DS19EQVRBKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdVc2luZyBtb2NrIGRhdGEgZm9yIGxlYWRlcmJvYXJkJyk7XG4gICAgICAgIC8vIFNvcnQgYW5kIGZpbHRlciB0aGUgbW9jayBsZWFkZXJib2FyZCBiYXNlZCBvbiB0aGUgcmVxdWVzdGVkIGNhdGVnb3J5XG4gICAgICAgIHJldHVybiBzYW1wbGVMZWFkZXJib2FyZFxuICAgICAgICAgIC5maWx0ZXIocGxheWVyID0+IHBsYXllci5oaWdoU2NvcmVzICYmIHBsYXllci5oaWdoU2NvcmVzW2NhdGVnb3J5XSlcbiAgICAgICAgICAuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2NvcmVBID0gYS5oaWdoU2NvcmVzPy5bY2F0ZWdvcnldIHx8IDA7XG4gICAgICAgICAgICBjb25zdCBzY29yZUIgPSBiLmhpZ2hTY29yZXM/LltjYXRlZ29yeV0gfHwgMDtcbiAgICAgICAgICAgIHJldHVybiBzY29yZUIgLSBzY29yZUE7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuc2xpY2UoMCwgMTApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBsZWFkZXJib2FyZFJlZiA9IGNvbGxlY3Rpb24oZGIsICdsZWFkZXJib2FyZCcpO1xuICAgICAgY29uc3QgcSA9IHF1ZXJ5KFxuICAgICAgICBsZWFkZXJib2FyZFJlZixcbiAgICAgICAgd2hlcmUoJ2NhdGVnb3J5JywgJz09JywgY2F0ZWdvcnkpLFxuICAgICAgICBvcmRlckJ5KCdzY29yZScsICdkZXNjJyksXG4gICAgICAgIGxpbWl0KDEwKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgY29uc3QgcXVlcnlTbmFwc2hvdCA9IGF3YWl0IGdldERvY3MocSk7XG4gICAgICBjb25zdCBsZWFkZXJib2FyZDogVHJlbmRHdWVzc2VyUGxheWVyW10gPSBbXTtcbiAgICAgIFxuICAgICAgcXVlcnlTbmFwc2hvdC5mb3JFYWNoKChkb2MpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGRvYy5kYXRhKCk7XG4gICAgICAgIGxlYWRlcmJvYXJkLnB1c2goe1xuICAgICAgICAgIHVpZDogZGF0YS51aWQsXG4gICAgICAgICAgbmFtZTogZGF0YS5uYW1lLFxuICAgICAgICAgIHNjb3JlOiBkYXRhLnNjb3JlLFxuICAgICAgICAgIGhpZ2hTY29yZXM6IGRhdGEuaGlnaFNjb3Jlc1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4gbGVhZGVyYm9hcmQ7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgbGVhZGVyYm9hcmQ6JywgZXJyb3IpO1xuICAgICAgXG4gICAgICBpZiAoVVNFX01PQ0tfREFUQSkge1xuICAgICAgICBjb25zb2xlLmxvZygnRmFsbGluZyBiYWNrIHRvIG1vY2sgZGF0YSBkdWUgdG8gZXJyb3InKTtcbiAgICAgICAgcmV0dXJuIHNhbXBsZUxlYWRlcmJvYXJkLnNsaWNlKDAsIDEwKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvLyBIZWxwZXIgbWV0aG9kc1xuICBwcml2YXRlIHN0YXRpYyBhc3luYyB1cGRhdGVIaWdoU2NvcmUoXG4gICAgcGxheWVyVWlkOiBzdHJpbmcsIFxuICAgIGNhdGVnb3J5OiBTZWFyY2hDYXRlZ29yeSwgXG4gICAgc2NvcmU6IG51bWJlclxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGxheWVyUmVmID0gZG9jKGRiLCAncGxheWVycycsIHBsYXllclVpZCk7XG4gICAgICBjb25zdCBwbGF5ZXJEb2MgPSBhd2FpdCBnZXREb2MocGxheWVyUmVmKTtcbiAgICAgIFxuICAgICAgaWYgKHBsYXllckRvYy5leGlzdHMoKSkge1xuICAgICAgICBjb25zdCBwbGF5ZXJEYXRhID0gcGxheWVyRG9jLmRhdGEoKTtcbiAgICAgICAgY29uc3QgY3VycmVudEhpZ2hTY29yZSA9IHBsYXllckRhdGEuaGlnaFNjb3Jlcz8uW2NhdGVnb3J5XSB8fCAwO1xuICAgICAgICBcbiAgICAgICAgaWYgKHNjb3JlID4gY3VycmVudEhpZ2hTY29yZSkge1xuICAgICAgICAgIC8vIFVwZGF0ZSBwbGF5ZXIncyBoaWdoIHNjb3JlIGZvciB0aGlzIGNhdGVnb3J5XG4gICAgICAgICAgYXdhaXQgdXBkYXRlRG9jKHBsYXllclJlZiwge1xuICAgICAgICAgICAgW2BoaWdoU2NvcmVzLiR7Y2F0ZWdvcnl9YF06IHNjb3JlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQWxzbyB1cGRhdGUgbGVhZGVyYm9hcmQgaWYgc2NvcmUgaXMgc2lnbmlmaWNhbnRcbiAgICAgICAgICBpZiAoc2NvcmUgPiA1KSB7XG4gICAgICAgICAgICBjb25zdCBsZWFkZXJib2FyZFJlZiA9IGRvYyhkYiwgJ2xlYWRlcmJvYXJkJywgYCR7Y2F0ZWdvcnl9XyR7cGxheWVyVWlkfWApO1xuICAgICAgICAgICAgYXdhaXQgc2V0RG9jKGxlYWRlcmJvYXJkUmVmLCB7XG4gICAgICAgICAgICAgIHVpZDogcGxheWVyVWlkLFxuICAgICAgICAgICAgICBuYW1lOiBwbGF5ZXJEYXRhLm5hbWUgfHwgJ1Vua25vd24gUGxheWVyJyxcbiAgICAgICAgICAgICAgc2NvcmUsXG4gICAgICAgICAgICAgIGNhdGVnb3J5LFxuICAgICAgICAgICAgICB1cGRhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpXG4gICAgICAgICAgICB9LCB7IG1lcmdlOiB0cnVlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGhpZ2ggc2NvcmU6JywgZXJyb3IpO1xuICAgICAgLy8gRG9uJ3QgdGhyb3csIGp1c3QgbG9nIC0gdGhpcyBpcyBhIG5vbi1jcml0aWNhbCBvcGVyYXRpb25cbiAgICB9XG4gIH1cbiAgXG4gIHByaXZhdGUgc3RhdGljIGFzeW5jIGZldGNoVGVybXNCeUNhdGVnb3J5KGNhdGVnb3J5OiBTZWFyY2hDYXRlZ29yeSk6IFByb21pc2U8U2VhcmNoVGVybVtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChVU0VfTU9DS19EQVRBKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdVc2luZyBtb2NrIGRhdGEgZm9yIHNlYXJjaCB0ZXJtcycpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGNhdGVnb3J5ID09PSAnZXZlcnl0aGluZycpIHtcbiAgICAgICAgICAvLyBSZXR1cm4gYWxsIHNhbXBsZSB0ZXJtc1xuICAgICAgICAgIHJldHVybiBzYW1wbGVTZWFyY2hUZXJtcztcbiAgICAgICAgfSBlbHNlIGlmIChjYXRlZ29yeSA9PT0gJ2xhdGVzdCcpIHtcbiAgICAgICAgICAvLyBSZXR1cm4gdGVybXMgc29ydGVkIGJ5IHRpbWVzdGFtcFxuICAgICAgICAgIHJldHVybiBbLi4uc2FtcGxlU2VhcmNoVGVybXNdLnNvcnQoKCkgPT4gTWF0aC5yYW5kb20oKSAtIDAuNSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRmlsdGVyIGJ5IGNhdGVnb3J5XG4gICAgICAgICAgY29uc3QgZmlsdGVyZWRUZXJtcyA9IHNhbXBsZVNlYXJjaFRlcm1zLmZpbHRlcih0ZXJtID0+IHRlcm0uY2F0ZWdvcnkgPT09IGNhdGVnb3J5KTtcbiAgICAgICAgICByZXR1cm4gZmlsdGVyZWRUZXJtcy5sZW5ndGggPiAwID8gZmlsdGVyZWRUZXJtcyA6IHNhbXBsZVNlYXJjaFRlcm1zO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHRlcm1zUmVmID0gY29sbGVjdGlvbihkYiwgJ3NlYXJjaFRlcm1zJyk7XG4gICAgICBsZXQgcTtcbiAgICAgIFxuICAgICAgaWYgKGNhdGVnb3J5ID09PSAnZXZlcnl0aGluZycpIHtcbiAgICAgICAgLy8gRm9yIFwiZXZlcnl0aGluZ1wiIGNhdGVnb3J5LCBnZXQgYSBtaXggb2YgYWxsIGNhdGVnb3JpZXNcbiAgICAgICAgcSA9IHF1ZXJ5KHRlcm1zUmVmLCBsaW1pdCg1MCkpO1xuICAgICAgfSBlbHNlIGlmIChjYXRlZ29yeSA9PT0gJ2xhdGVzdCcpIHtcbiAgICAgICAgLy8gRm9yIFwibGF0ZXN0XCIsIGdldCB0aGUgbW9zdCByZWNlbnRseSBhZGRlZCB0ZXJtc1xuICAgICAgICBxID0gcXVlcnkodGVybXNSZWYsIG9yZGVyQnkoJ3RpbWVzdGFtcCcsICdkZXNjJyksIGxpbWl0KDUwKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igc3BlY2lmaWMgY2F0ZWdvcmllc1xuICAgICAgICBxID0gcXVlcnkodGVybXNSZWYsIHdoZXJlKCdjYXRlZ29yeScsICc9PScsIGNhdGVnb3J5KSwgbGltaXQoNTApKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgcXVlcnlTbmFwc2hvdCA9IGF3YWl0IGdldERvY3MocSk7XG4gICAgICBjb25zdCB0ZXJtczogU2VhcmNoVGVybVtdID0gW107XG4gICAgICBcbiAgICAgIHF1ZXJ5U25hcHNob3QuZm9yRWFjaCgoZG9jKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBkb2MuZGF0YSgpIGFzIFNlYXJjaFRlcm07XG4gICAgICAgIHRlcm1zLnB1c2goe1xuICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgaWQ6IGRvYy5pZFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4gdGVybXM7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgdGVybXM6JywgZXJyb3IpO1xuICAgICAgXG4gICAgICBpZiAoVVNFX01PQ0tfREFUQSkge1xuICAgICAgICBjb25zb2xlLmxvZygnRmFsbGluZyBiYWNrIHRvIG1vY2sgZGF0YSBkdWUgdG8gZXJyb3InKTtcbiAgICAgICAgcmV0dXJuIHNhbXBsZVNlYXJjaFRlcm1zO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIHByaXZhdGUgc3RhdGljIGFzeW5jIGZldGNoQ3VzdG9tVGVybVdpdGhSZWxhdGVkKGN1c3RvbVRlcm06IHN0cmluZyk6IFByb21pc2U8U2VhcmNoVGVybVtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoaXMgd291bGQgdHlwaWNhbGx5IGNhbGwgYSBGaXJlYmFzZSBGdW5jdGlvbiB0byBnZXQgdGhlIGN1c3RvbSB0ZXJtIGRhdGFcbiAgICAgIC8vIEZvciBub3csIHdlJ2xsIHNpbXVsYXRlIGl0IHdpdGggYSBwbGFjZWhvbGRlclxuICAgICAgXG4gICAgICAvLyBGaXJzdCB0ZXJtIHdpbGwgYmUgdGhlIGN1c3RvbSBvbmVcbiAgICAgIGNvbnN0IGN1c3RvbVNlYXJjaFRlcm06IFNlYXJjaFRlcm0gPSB7XG4gICAgICAgIGlkOiB1dWlkdjQoKSxcbiAgICAgICAgdGVybTogY3VzdG9tVGVybSxcbiAgICAgICAgdm9sdW1lOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDApICsgMSwgLy8gUGxhY2Vob2xkZXIgdm9sdW1lXG4gICAgICAgIGNhdGVnb3J5OiAnY3VzdG9tJyxcbiAgICAgICAgaW1hZ2VVcmw6IGBodHRwczovL3NvdXJjZS51bnNwbGFzaC5jb20vZmVhdHVyZWQvPyR7ZW5jb2RlVVJJQ29tcG9uZW50KGN1c3RvbVRlcm0pfWAsXG4gICAgICAgIHRpbWVzdGFtcDogVGltZXN0YW1wLm5vdygpXG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBUaGVuIGdldCBzb21lIHJlbGF0ZWQgdGVybXMgZnJvbSB0aGUgZGF0YWJhc2UgKHJhbmRvbSBmb3Igbm93KVxuICAgICAgY29uc3QgdGVybXNSZWYgPSBjb2xsZWN0aW9uKGRiLCAnc2VhcmNoVGVybXMnKTtcbiAgICAgIGNvbnN0IHEgPSBxdWVyeSh0ZXJtc1JlZiwgbGltaXQoMjApKTtcbiAgICAgIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpO1xuICAgICAgXG4gICAgICBjb25zdCB0ZXJtczogU2VhcmNoVGVybVtdID0gW2N1c3RvbVNlYXJjaFRlcm1dO1xuICAgICAgXG4gICAgICBxdWVyeVNuYXBzaG90LmZvckVhY2goKGRvYykgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0gZG9jLmRhdGEoKSBhcyBTZWFyY2hUZXJtO1xuICAgICAgICB0ZXJtcy5wdXNoKHtcbiAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgIGlkOiBkb2MuaWRcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHRlcm1zO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGN1c3RvbSB0ZXJtOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgcHJpdmF0ZSBzdGF0aWMgc2h1ZmZsZVRlcm1zKHRlcm1zOiBTZWFyY2hUZXJtW10pOiBTZWFyY2hUZXJtW10ge1xuICAgIGNvbnN0IHNodWZmbGVkID0gWy4uLnRlcm1zXTtcbiAgICBmb3IgKGxldCBpID0gc2h1ZmZsZWQubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgY29uc3QgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xuICAgICAgW3NodWZmbGVkW2ldLCBzaHVmZmxlZFtqXV0gPSBbc2h1ZmZsZWRbal0sIHNodWZmbGVkW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHNodWZmbGVkO1xuICB9XG4gIFxuICBwcml2YXRlIHN0YXRpYyBnZW5lcmF0ZUdhbWVJZCgpOiBzdHJpbmcge1xuICAgIC8vIEdlbmVyYXRlIGEgNi1jaGFyYWN0ZXIgYWxwaGFudW1lcmljIGNvZGUgKHVwcGVyY2FzZSlcbiAgICBjb25zdCBjaGFycyA9ICdBQkNERUZHSEpLTE1OUFFSU1RVVldYWVoyMzQ1Njc4OSc7IC8vIFJlbW92ZWQgY29uZnVzYWJsZSBjaGFyYWN0ZXJzXG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICByZXN1bHQgKz0gY2hhcnMuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJzLmxlbmd0aCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59Il0sIm5hbWVzIjpbImRvYyIsInNldERvYyIsInVwZGF0ZURvYyIsImdldERvYyIsImNvbGxlY3Rpb24iLCJxdWVyeSIsIndoZXJlIiwiZ2V0RG9jcyIsIlRpbWVzdGFtcCIsInNlcnZlclRpbWVzdGFtcCIsImxpbWl0Iiwib3JkZXJCeSIsImRiIiwidjQiLCJ1dWlkdjQiLCJzYW1wbGVTZWFyY2hUZXJtcyIsInNhbXBsZUxlYWRlcmJvYXJkIiwiVVNFX01PQ0tfREFUQSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19VU0VfTU9DS19EQVRBIiwiVHJlbmRHdWVzc2VyU2VydmljZSIsInN0YXJ0R2FtZSIsImdhbWVJZCIsImNhdGVnb3J5IiwiY3VzdG9tVGVybSIsImdhbWVSZWYiLCJ0b1VwcGVyQ2FzZSIsImdhbWVEb2MiLCJleGlzdHMiLCJFcnJvciIsImNvbnNvbGUiLCJsb2ciLCJ0ZXJtcyIsImZldGNoQ3VzdG9tVGVybVdpdGhSZWxhdGVkIiwiZmV0Y2hUZXJtc0J5Q2F0ZWdvcnkiLCJsZW5ndGgiLCJzaHVmZmxlZFRlcm1zIiwic2h1ZmZsZVRlcm1zIiwiZ2FtZVN0YXRlIiwiY3VycmVudFJvdW5kIiwia25vd25UZXJtIiwiaGlkZGVuVGVybSIsInN0YXJ0ZWQiLCJmaW5pc2hlZCIsInVzZWRUZXJtcyIsImlkIiwic2xpY2UiLCJ1bmRlZmluZWQiLCJzdGF0dXMiLCJzZXNzaW9uU3RvcmFnZSIsInNldEl0ZW0iLCJKU09OIiwic3RyaW5naWZ5IiwiZ2V0SXRlbSIsInVpZCIsIm5hbWUiLCJzY29yZSIsImVycm9yIiwibWFrZUd1ZXNzIiwicGxheWVyVWlkIiwiaXNIaWdoZXIiLCJnYW1lRGF0YSIsImRhdGEiLCJwbGF5ZXIiLCJpc0NvcnJlY3QiLCJ2b2x1bWUiLCJuZXh0Um91bmQiLCJuZXdQbGF5ZXJTY29yZSIsIm5leHRUZXJtIiwicmVtYWluaW5nVGVybXMiLCJ1cGRhdGVkU3RhdGUiLCJ3aW5uZXIiLCJ1cGRhdGVIaWdoU2NvcmUiLCJlbmRHYW1lIiwiZmluYWxTY29yZSIsImNyZWF0ZUdhbWUiLCJjcmVhdGVkQnkiLCJwbGF5ZXJOYW1lIiwiZ2VuZXJhdGVHYW1lSWQiLCJwbGF5ZXJEYXRhIiwiY3JlYXRlZEF0IiwiZ2FtZVR5cGUiLCJnZXRMZWFkZXJib2FyZCIsImZpbHRlciIsImhpZ2hTY29yZXMiLCJzb3J0IiwiYSIsImIiLCJzY29yZUEiLCJzY29yZUIiLCJsZWFkZXJib2FyZFJlZiIsInEiLCJxdWVyeVNuYXBzaG90IiwibGVhZGVyYm9hcmQiLCJmb3JFYWNoIiwicHVzaCIsInBsYXllclJlZiIsInBsYXllckRvYyIsImN1cnJlbnRIaWdoU2NvcmUiLCJ1cGRhdGVkQXQiLCJtZXJnZSIsIk1hdGgiLCJyYW5kb20iLCJmaWx0ZXJlZFRlcm1zIiwidGVybSIsInRlcm1zUmVmIiwiY3VzdG9tU2VhcmNoVGVybSIsImZsb29yIiwiaW1hZ2VVcmwiLCJlbmNvZGVVUklDb21wb25lbnQiLCJ0aW1lc3RhbXAiLCJub3ciLCJzaHVmZmxlZCIsImkiLCJqIiwiY2hhcnMiLCJyZXN1bHQiLCJjaGFyQXQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/lib/firebase/trendGuesserService.ts\n"));

/***/ })

});