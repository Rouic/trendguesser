"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "(pages-dir-browser)/./src/lib/firebase/trendGuesserService.ts":
/*!*************************************************!*\
  !*** ./src/lib/firebase/trendGuesserService.ts ***!
  \*************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TrendGuesserService: () => (/* binding */ TrendGuesserService)\n/* harmony export */ });\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/firestore */ \"(pages-dir-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./firebase */ \"(pages-dir-browser)/./src/lib/firebase/firebase.ts\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// src/lib/firebase/trendGuesserService.ts\n\n\n\n// Development mode flag\nconst USE_MOCK_DATA = process.env.NEXT_PUBLIC_USE_MOCK_DATA === 'true' || \"development\" === 'development';\nclass TrendGuesserService {\n    // Start a new game with selected category\n    static async startGame(gameId, category, customTerm) {\n        try {\n            const gameRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'games', gameId.toUpperCase());\n            const gameDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(gameRef);\n            if (!gameDoc.exists()) {\n                throw new Error('Game does not exist');\n            }\n            // Get terms for the selected category\n            let terms = [];\n            if (category === 'custom' && customTerm) {\n                // For custom games, fetch the custom term and related terms\n                terms = await this.fetchCustomTermWithRelated(customTerm);\n            } else {\n                // For predefined categories, fetch terms from the database\n                terms = await this.fetchTermsByCategory(category);\n            }\n            if (terms.length < 2) {\n                throw new Error('Not enough terms available');\n            }\n            // Shuffle the terms\n            const shuffledTerms = this.shuffleTerms(terms);\n            // Initialize game state with first two terms\n            const gameState = {\n                currentRound: 1,\n                knownTerm: shuffledTerms[0],\n                hiddenTerm: shuffledTerms[1],\n                category,\n                started: true,\n                finished: false,\n                usedTerms: [\n                    shuffledTerms[0].id,\n                    shuffledTerms[1].id\n                ],\n                terms: shuffledTerms.slice(2),\n                customTerm: category === 'custom' ? customTerm : undefined\n            };\n            // Update the game document with new game state\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(gameRef, {\n                status: 'active',\n                '__trendguesser.state': gameState\n            });\n        } catch (error) {\n            console.error('Error starting game:', error);\n            throw error;\n        }\n    }\n    // Make a guess (higher or lower)\n    static async makeGuess(gameId, playerUid, isHigher) {\n        try {\n            const gameRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'games', gameId.toUpperCase());\n            const gameDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(gameRef);\n            if (!gameDoc.exists()) {\n                throw new Error('Game does not exist');\n            }\n            const gameData = gameDoc.data();\n            const gameState = gameData['__trendguesser.state'];\n            const player = gameData[playerUid];\n            if (!gameState || !gameState.started || gameState.finished) {\n                throw new Error('Game is not active');\n            }\n            // Check if the guess is correct\n            const isCorrect = isHigher ? gameState.hiddenTerm.volume > gameState.knownTerm.volume : gameState.hiddenTerm.volume < gameState.knownTerm.volume;\n            if (isCorrect) {\n                // Correct guess - prepare next round\n                const nextRound = gameState.currentRound + 1;\n                const newPlayerScore = (player.score || 0) + 1;\n                // Update player score\n                await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(gameRef, {\n                    [\"\".concat(playerUid, \".score\")]: newPlayerScore\n                });\n                // If we have more terms, set up next round\n                if (gameState.terms.length > 0) {\n                    const nextTerm = gameState.terms[0];\n                    const remainingTerms = gameState.terms.slice(1);\n                    const updatedState = {\n                        ...gameState,\n                        currentRound: nextRound,\n                        knownTerm: gameState.hiddenTerm,\n                        hiddenTerm: nextTerm,\n                        usedTerms: [\n                            ...gameState.usedTerms,\n                            nextTerm.id\n                        ],\n                        terms: remainingTerms\n                    };\n                    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(gameRef, {\n                        '__trendguesser.state': updatedState\n                    });\n                } else {\n                    // No more terms - player wins by completing all terms\n                    const updatedState = {\n                        ...gameState,\n                        finished: true,\n                        winner: playerUid\n                    };\n                    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(gameRef, {\n                        '__trendguesser.state': updatedState,\n                        status: 'finished'\n                    });\n                    // Update high score if needed\n                    await this.updateHighScore(playerUid, gameState.category, newPlayerScore);\n                }\n                return true;\n            } else {\n                // Incorrect guess - game over\n                const updatedState = {\n                    ...gameState,\n                    finished: true\n                };\n                await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(gameRef, {\n                    '__trendguesser.state': updatedState,\n                    status: 'finished'\n                });\n                // Update high score if needed\n                await this.updateHighScore(playerUid, gameState.category, player.score || 0);\n                return false;\n            }\n        } catch (error) {\n            console.error('Error making guess:', error);\n            throw error;\n        }\n    }\n    // End the game and update high scores\n    static async endGame(gameId, playerUid, finalScore) {\n        try {\n            const gameRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'games', gameId.toUpperCase());\n            const gameDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(gameRef);\n            if (!gameDoc.exists()) {\n                throw new Error('Game does not exist');\n            }\n            const gameData = gameDoc.data();\n            const gameState = gameData['__trendguesser.state'];\n            if (!gameState) {\n                throw new Error('No game state found');\n            }\n            // Only update if game was actually started\n            if (gameState.started) {\n                // Mark game as finished\n                await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(gameRef, {\n                    status: 'finished',\n                    '__trendguesser.state': {\n                        ...gameState,\n                        finished: true\n                    }\n                });\n                // Update high score if needed\n                await this.updateHighScore(playerUid, gameState.category, finalScore);\n            }\n        } catch (error) {\n            console.error('Error ending game:', error);\n            throw error;\n        }\n    }\n    // Create a new game session\n    static async createGame(createdBy, playerName) {\n        try {\n            // Generate a short 6-character game ID (uppercase)\n            const gameId = this.generateGameId();\n            const gameRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'games', gameId);\n            // Initialize player data\n            const playerData = {\n                uid: createdBy,\n                name: playerName || 'Player',\n                score: 0\n            };\n            // Initial game data\n            const gameData = {\n                id: gameId,\n                createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n                createdBy,\n                gameType: 'trendguesser',\n                status: 'waiting',\n                [createdBy]: playerData\n            };\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setDoc)(gameRef, gameData);\n            return gameId;\n        } catch (error) {\n            console.error('Error creating game:', error);\n            throw error;\n        }\n    }\n    // Fetch leaderboard for a category\n    static async getLeaderboard(category) {\n        try {\n            const leaderboardRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'leaderboard');\n            const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(leaderboardRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('category', '==', category), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)('score', 'desc'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.limit)(10));\n            const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n            const leaderboard = [];\n            querySnapshot.forEach((doc)=>{\n                const data = doc.data();\n                leaderboard.push({\n                    uid: data.uid,\n                    name: data.name,\n                    score: data.score,\n                    highScores: data.highScores\n                });\n            });\n            return leaderboard;\n        } catch (error) {\n            console.error('Error fetching leaderboard:', error);\n            throw error;\n        }\n    }\n    // Helper methods\n    static async updateHighScore(playerUid, category, score) {\n        try {\n            const playerRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'players', playerUid);\n            const playerDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(playerRef);\n            if (playerDoc.exists()) {\n                var _playerData_highScores;\n                const playerData = playerDoc.data();\n                const currentHighScore = ((_playerData_highScores = playerData.highScores) === null || _playerData_highScores === void 0 ? void 0 : _playerData_highScores[category]) || 0;\n                if (score > currentHighScore) {\n                    // Update player's high score for this category\n                    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(playerRef, {\n                        [\"highScores.\".concat(category)]: score\n                    });\n                    // Also update leaderboard if score is significant\n                    if (score > 5) {\n                        const leaderboardRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'leaderboard', \"\".concat(category, \"_\").concat(playerUid));\n                        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setDoc)(leaderboardRef, {\n                            uid: playerUid,\n                            name: playerData.name || 'Unknown Player',\n                            score,\n                            category,\n                            updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)()\n                        }, {\n                            merge: true\n                        });\n                    }\n                }\n            }\n        } catch (error) {\n            console.error('Error updating high score:', error);\n        // Don't throw, just log - this is a non-critical operation\n        }\n    }\n    static async fetchTermsByCategory(category) {\n        try {\n            const termsRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'searchTerms');\n            let q;\n            if (category === 'everything') {\n                // For \"everything\" category, get a mix of all categories\n                q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(termsRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.limit)(50));\n            } else if (category === 'latest') {\n                // For \"latest\", get the most recently added terms\n                q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(termsRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)('timestamp', 'desc'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.limit)(50));\n            } else {\n                // For specific categories\n                q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(termsRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('category', '==', category), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.limit)(50));\n            }\n            const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n            const terms = [];\n            querySnapshot.forEach((doc)=>{\n                const data = doc.data();\n                terms.push({\n                    ...data,\n                    id: doc.id\n                });\n            });\n            return terms;\n        } catch (error) {\n            console.error('Error fetching terms:', error);\n            throw error;\n        }\n    }\n    static async fetchCustomTermWithRelated(customTerm) {\n        try {\n            // This would typically call a Firebase Function to get the custom term data\n            // For now, we'll simulate it with a placeholder\n            // First term will be the custom one\n            const customSearchTerm = {\n                id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__.v4)(),\n                term: customTerm,\n                volume: Math.floor(Math.random() * 100) + 1,\n                category: 'custom',\n                imageUrl: \"https://source.unsplash.com/featured/?\".concat(encodeURIComponent(customTerm)),\n                timestamp: firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.Timestamp.now()\n            };\n            // Then get some related terms from the database (random for now)\n            const termsRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, 'searchTerms');\n            const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(termsRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.limit)(20));\n            const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n            const terms = [\n                customSearchTerm\n            ];\n            querySnapshot.forEach((doc)=>{\n                const data = doc.data();\n                terms.push({\n                    ...data,\n                    id: doc.id\n                });\n            });\n            return terms;\n        } catch (error) {\n            console.error('Error fetching custom term:', error);\n            throw error;\n        }\n    }\n    static shuffleTerms(terms) {\n        const shuffled = [\n            ...terms\n        ];\n        for(let i = shuffled.length - 1; i > 0; i--){\n            const j = Math.floor(Math.random() * (i + 1));\n            [shuffled[i], shuffled[j]] = [\n                shuffled[j],\n                shuffled[i]\n            ];\n        }\n        return shuffled;\n    }\n    static generateGameId() {\n        // Generate a 6-character alphanumeric code (uppercase)\n        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Removed confusable characters\n        let result = '';\n        for(let i = 0; i < 6; i++){\n            result += chars.charAt(Math.floor(Math.random() * chars.length));\n        }\n        return result;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9saWIvZmlyZWJhc2UvdHJlbmRHdWVzc2VyU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLDBDQUEwQztBQWdCZDtBQUNJO0FBQ0k7QUFJcEMsd0JBQXdCO0FBQ3hCLE1BQU1lLGdCQUFnQkMsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyx5QkFBeUIsS0FBSyxVQUN6Q0Ysa0JBQXlCO0FBRXpDLE1BQU1HO0lBQ1gsMENBQTBDO0lBQzFDLGFBQWFDLFVBQVVDLE1BQWMsRUFBRUMsUUFBd0IsRUFBRUMsVUFBbUIsRUFBaUI7UUFDbkcsSUFBSTtZQUNGLE1BQU1DLFVBQVV4Qix1REFBR0EsQ0FBQ1kseUNBQUVBLEVBQUUsU0FBU1MsT0FBT0ksV0FBVztZQUNuRCxNQUFNQyxVQUFVLE1BQU12QiwwREFBTUEsQ0FBQ3FCO1lBRTdCLElBQUksQ0FBQ0UsUUFBUUMsTUFBTSxJQUFJO2dCQUNyQixNQUFNLElBQUlDLE1BQU07WUFDbEI7WUFFQSxzQ0FBc0M7WUFDdEMsSUFBSUMsUUFBc0IsRUFBRTtZQUU1QixJQUFJUCxhQUFhLFlBQVlDLFlBQVk7Z0JBQ3ZDLDREQUE0RDtnQkFDNURNLFFBQVEsTUFBTSxJQUFJLENBQUNDLDBCQUEwQixDQUFDUDtZQUNoRCxPQUFPO2dCQUNMLDJEQUEyRDtnQkFDM0RNLFFBQVEsTUFBTSxJQUFJLENBQUNFLG9CQUFvQixDQUFDVDtZQUMxQztZQUVBLElBQUlPLE1BQU1HLE1BQU0sR0FBRyxHQUFHO2dCQUNwQixNQUFNLElBQUlKLE1BQU07WUFDbEI7WUFFQSxvQkFBb0I7WUFDcEIsTUFBTUssZ0JBQWdCLElBQUksQ0FBQ0MsWUFBWSxDQUFDTDtZQUV4Qyw2Q0FBNkM7WUFDN0MsTUFBTU0sWUFBbUM7Z0JBQ3ZDQyxjQUFjO2dCQUNkQyxXQUFXSixhQUFhLENBQUMsRUFBRTtnQkFDM0JLLFlBQVlMLGFBQWEsQ0FBQyxFQUFFO2dCQUM1Qlg7Z0JBQ0FpQixTQUFTO2dCQUNUQyxVQUFV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QUFlN0IsaUJBQXlCO1FBQ3RDLHVEQUF1RDtRQUN2RCxNQUFNZ0MsUUFBUSxvQ0FBb0MsZ0NBQWdDO1FBQ2xGLElBQUlDLFNBQVM7UUFDYixJQUFLLElBQUlILElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO1lBQzFCRyxVQUFVRCxNQUFNRSxNQUFNLENBQUNaLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFLUSxNQUFNckUsTUFBTTtRQUNoRTtRQUNBLE9BQU9zRTtJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGV4L0RldmVsb3Blci90cmVuZGd1ZXNzZXIvc3JjL2xpYi9maXJlYmFzZS90cmVuZEd1ZXNzZXJTZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9saWIvZmlyZWJhc2UvdHJlbmRHdWVzc2VyU2VydmljZS50c1xuaW1wb3J0IHsgXG4gIGRvYywgXG4gIHNldERvYywgXG4gIHVwZGF0ZURvYywgXG4gIGdldERvYywgXG4gIGNvbGxlY3Rpb24sIFxuICBxdWVyeSwgXG4gIHdoZXJlLCBcbiAgZ2V0RG9jcywgXG4gIGFycmF5VW5pb24sIFxuICBUaW1lc3RhbXAsIFxuICBzZXJ2ZXJUaW1lc3RhbXAsXG4gIGluY3JlbWVudCxcbiAgbGltaXQsXG4gIG9yZGVyQnlcbn0gZnJvbSAnZmlyZWJhc2UvZmlyZXN0b3JlJztcbmltcG9ydCB7IGRiIH0gZnJvbSAnLi9maXJlYmFzZSc7XG5pbXBvcnQgeyB2NCBhcyB1dWlkdjQgfSBmcm9tICd1dWlkJztcbmltcG9ydCB7IFNlYXJjaENhdGVnb3J5LCBTZWFyY2hUZXJtLCBUcmVuZEd1ZXNzZXJHYW1lU3RhdGUsIFRyZW5kR3Vlc3NlclBsYXllciB9IGZyb20gJ0AvdHlwZXMnO1xuaW1wb3J0IHsgc2FtcGxlU2VhcmNoVGVybXMsIHNhbXBsZUxlYWRlcmJvYXJkIH0gZnJvbSAnLi9tb2NrRGF0YSc7XG5cbi8vIERldmVsb3BtZW50IG1vZGUgZmxhZ1xuY29uc3QgVVNFX01PQ0tfREFUQSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1VTRV9NT0NLX0RBVEEgPT09ICd0cnVlJyB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCc7XG5cbmV4cG9ydCBjbGFzcyBUcmVuZEd1ZXNzZXJTZXJ2aWNlIHtcbiAgLy8gU3RhcnQgYSBuZXcgZ2FtZSB3aXRoIHNlbGVjdGVkIGNhdGVnb3J5XG4gIHN0YXRpYyBhc3luYyBzdGFydEdhbWUoZ2FtZUlkOiBzdHJpbmcsIGNhdGVnb3J5OiBTZWFyY2hDYXRlZ29yeSwgY3VzdG9tVGVybT86IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBnYW1lUmVmID0gZG9jKGRiLCAnZ2FtZXMnLCBnYW1lSWQudG9VcHBlckNhc2UoKSk7XG4gICAgICBjb25zdCBnYW1lRG9jID0gYXdhaXQgZ2V0RG9jKGdhbWVSZWYpO1xuICAgICAgXG4gICAgICBpZiAoIWdhbWVEb2MuZXhpc3RzKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHYW1lIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEdldCB0ZXJtcyBmb3IgdGhlIHNlbGVjdGVkIGNhdGVnb3J5XG4gICAgICBsZXQgdGVybXM6IFNlYXJjaFRlcm1bXSA9IFtdO1xuICAgICAgXG4gICAgICBpZiAoY2F0ZWdvcnkgPT09ICdjdXN0b20nICYmIGN1c3RvbVRlcm0pIHtcbiAgICAgICAgLy8gRm9yIGN1c3RvbSBnYW1lcywgZmV0Y2ggdGhlIGN1c3RvbSB0ZXJtIGFuZCByZWxhdGVkIHRlcm1zXG4gICAgICAgIHRlcm1zID0gYXdhaXQgdGhpcy5mZXRjaEN1c3RvbVRlcm1XaXRoUmVsYXRlZChjdXN0b21UZXJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBwcmVkZWZpbmVkIGNhdGVnb3JpZXMsIGZldGNoIHRlcm1zIGZyb20gdGhlIGRhdGFiYXNlXG4gICAgICAgIHRlcm1zID0gYXdhaXQgdGhpcy5mZXRjaFRlcm1zQnlDYXRlZ29yeShjYXRlZ29yeSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICh0ZXJtcy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGVub3VnaCB0ZXJtcyBhdmFpbGFibGUnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2h1ZmZsZSB0aGUgdGVybXNcbiAgICAgIGNvbnN0IHNodWZmbGVkVGVybXMgPSB0aGlzLnNodWZmbGVUZXJtcyh0ZXJtcyk7XG4gICAgICBcbiAgICAgIC8vIEluaXRpYWxpemUgZ2FtZSBzdGF0ZSB3aXRoIGZpcnN0IHR3byB0ZXJtc1xuICAgICAgY29uc3QgZ2FtZVN0YXRlOiBUcmVuZEd1ZXNzZXJHYW1lU3RhdGUgPSB7XG4gICAgICAgIGN1cnJlbnRSb3VuZDogMSxcbiAgICAgICAga25vd25UZXJtOiBzaHVmZmxlZFRlcm1zWzBdLFxuICAgICAgICBoaWRkZW5UZXJtOiBzaHVmZmxlZFRlcm1zWzFdLFxuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgc3RhcnRlZDogdHJ1ZSxcbiAgICAgICAgZmluaXNoZWQ6IGZhbHNlLFxuICAgICAgICB1c2VkVGVybXM6IFtzaHVmZmxlZFRlcm1zWzBdLmlkLCBzaHVmZmxlZFRlcm1zWzFdLmlkXSxcbiAgICAgICAgdGVybXM6IHNodWZmbGVkVGVybXMuc2xpY2UoMiksIC8vIFN0b3JlIHJlbWFpbmluZyB0ZXJtc1xuICAgICAgICBjdXN0b21UZXJtOiBjYXRlZ29yeSA9PT0gJ2N1c3RvbScgPyBjdXN0b21UZXJtIDogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgdGhlIGdhbWUgZG9jdW1lbnQgd2l0aCBuZXcgZ2FtZSBzdGF0ZVxuICAgICAgYXdhaXQgdXBkYXRlRG9jKGdhbWVSZWYsIHtcbiAgICAgICAgc3RhdHVzOiAnYWN0aXZlJyxcbiAgICAgICAgJ19fdHJlbmRndWVzc2VyLnN0YXRlJzogZ2FtZVN0YXRlXG4gICAgICB9KTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzdGFydGluZyBnYW1lOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gTWFrZSBhIGd1ZXNzIChoaWdoZXIgb3IgbG93ZXIpXG4gIHN0YXRpYyBhc3luYyBtYWtlR3Vlc3MoZ2FtZUlkOiBzdHJpbmcsIHBsYXllclVpZDogc3RyaW5nLCBpc0hpZ2hlcjogYm9vbGVhbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBnYW1lUmVmID0gZG9jKGRiLCAnZ2FtZXMnLCBnYW1lSWQudG9VcHBlckNhc2UoKSk7XG4gICAgICBjb25zdCBnYW1lRG9jID0gYXdhaXQgZ2V0RG9jKGdhbWVSZWYpO1xuICAgICAgXG4gICAgICBpZiAoIWdhbWVEb2MuZXhpc3RzKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHYW1lIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGdhbWVEYXRhID0gZ2FtZURvYy5kYXRhKCk7XG4gICAgICBjb25zdCBnYW1lU3RhdGUgPSBnYW1lRGF0YVsnX190cmVuZGd1ZXNzZXIuc3RhdGUnXSBhcyBUcmVuZEd1ZXNzZXJHYW1lU3RhdGU7XG4gICAgICBjb25zdCBwbGF5ZXIgPSBnYW1lRGF0YVtwbGF5ZXJVaWRdIGFzIFRyZW5kR3Vlc3NlclBsYXllcjtcbiAgICAgIFxuICAgICAgaWYgKCFnYW1lU3RhdGUgfHwgIWdhbWVTdGF0ZS5zdGFydGVkIHx8IGdhbWVTdGF0ZS5maW5pc2hlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dhbWUgaXMgbm90IGFjdGl2ZScpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0aGUgZ3Vlc3MgaXMgY29ycmVjdFxuICAgICAgY29uc3QgaXNDb3JyZWN0ID0gaXNIaWdoZXIgXG4gICAgICAgID8gZ2FtZVN0YXRlLmhpZGRlblRlcm0udm9sdW1lID4gZ2FtZVN0YXRlLmtub3duVGVybS52b2x1bWVcbiAgICAgICAgOiBnYW1lU3RhdGUuaGlkZGVuVGVybS52b2x1bWUgPCBnYW1lU3RhdGUua25vd25UZXJtLnZvbHVtZTtcbiAgICAgIFxuICAgICAgaWYgKGlzQ29ycmVjdCkge1xuICAgICAgICAvLyBDb3JyZWN0IGd1ZXNzIC0gcHJlcGFyZSBuZXh0IHJvdW5kXG4gICAgICAgIGNvbnN0IG5leHRSb3VuZCA9IGdhbWVTdGF0ZS5jdXJyZW50Um91bmQgKyAxO1xuICAgICAgICBjb25zdCBuZXdQbGF5ZXJTY29yZSA9IChwbGF5ZXIuc2NvcmUgfHwgMCkgKyAxO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHBsYXllciBzY29yZVxuICAgICAgICBhd2FpdCB1cGRhdGVEb2MoZ2FtZVJlZiwge1xuICAgICAgICAgIFtgJHtwbGF5ZXJVaWR9LnNjb3JlYF06IG5ld1BsYXllclNjb3JlXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBtb3JlIHRlcm1zLCBzZXQgdXAgbmV4dCByb3VuZFxuICAgICAgICBpZiAoZ2FtZVN0YXRlLnRlcm1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBuZXh0VGVybSA9IGdhbWVTdGF0ZS50ZXJtc1swXTtcbiAgICAgICAgICBjb25zdCByZW1haW5pbmdUZXJtcyA9IGdhbWVTdGF0ZS50ZXJtcy5zbGljZSgxKTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCB1cGRhdGVkU3RhdGU6IFRyZW5kR3Vlc3NlckdhbWVTdGF0ZSA9IHtcbiAgICAgICAgICAgIC4uLmdhbWVTdGF0ZSxcbiAgICAgICAgICAgIGN1cnJlbnRSb3VuZDogbmV4dFJvdW5kLFxuICAgICAgICAgICAga25vd25UZXJtOiBnYW1lU3RhdGUuaGlkZGVuVGVybSxcbiAgICAgICAgICAgIGhpZGRlblRlcm06IG5leHRUZXJtLFxuICAgICAgICAgICAgdXNlZFRlcm1zOiBbLi4uZ2FtZVN0YXRlLnVzZWRUZXJtcywgbmV4dFRlcm0uaWRdLFxuICAgICAgICAgICAgdGVybXM6IHJlbWFpbmluZ1Rlcm1zXG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICBhd2FpdCB1cGRhdGVEb2MoZ2FtZVJlZiwge1xuICAgICAgICAgICAgJ19fdHJlbmRndWVzc2VyLnN0YXRlJzogdXBkYXRlZFN0YXRlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gbW9yZSB0ZXJtcyAtIHBsYXllciB3aW5zIGJ5IGNvbXBsZXRpbmcgYWxsIHRlcm1zXG4gICAgICAgICAgY29uc3QgdXBkYXRlZFN0YXRlOiBUcmVuZEd1ZXNzZXJHYW1lU3RhdGUgPSB7XG4gICAgICAgICAgICAuLi5nYW1lU3RhdGUsXG4gICAgICAgICAgICBmaW5pc2hlZDogdHJ1ZSxcbiAgICAgICAgICAgIHdpbm5lcjogcGxheWVyVWlkXG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICBhd2FpdCB1cGRhdGVEb2MoZ2FtZVJlZiwge1xuICAgICAgICAgICAgJ19fdHJlbmRndWVzc2VyLnN0YXRlJzogdXBkYXRlZFN0YXRlLFxuICAgICAgICAgICAgc3RhdHVzOiAnZmluaXNoZWQnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVXBkYXRlIGhpZ2ggc2NvcmUgaWYgbmVlZGVkXG4gICAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVIaWdoU2NvcmUocGxheWVyVWlkLCBnYW1lU3RhdGUuY2F0ZWdvcnksIG5ld1BsYXllclNjb3JlKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJbmNvcnJlY3QgZ3Vlc3MgLSBnYW1lIG92ZXJcbiAgICAgICAgY29uc3QgdXBkYXRlZFN0YXRlOiBUcmVuZEd1ZXNzZXJHYW1lU3RhdGUgPSB7XG4gICAgICAgICAgLi4uZ2FtZVN0YXRlLFxuICAgICAgICAgIGZpbmlzaGVkOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBhd2FpdCB1cGRhdGVEb2MoZ2FtZVJlZiwge1xuICAgICAgICAgICdfX3RyZW5kZ3Vlc3Nlci5zdGF0ZSc6IHVwZGF0ZWRTdGF0ZSxcbiAgICAgICAgICBzdGF0dXM6ICdmaW5pc2hlZCdcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgaGlnaCBzY29yZSBpZiBuZWVkZWRcbiAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVIaWdoU2NvcmUocGxheWVyVWlkLCBnYW1lU3RhdGUuY2F0ZWdvcnksIHBsYXllci5zY29yZSB8fCAwKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBtYWtpbmcgZ3Vlc3M6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvLyBFbmQgdGhlIGdhbWUgYW5kIHVwZGF0ZSBoaWdoIHNjb3Jlc1xuICBzdGF0aWMgYXN5bmMgZW5kR2FtZShnYW1lSWQ6IHN0cmluZywgcGxheWVyVWlkOiBzdHJpbmcsIGZpbmFsU2NvcmU6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBnYW1lUmVmID0gZG9jKGRiLCAnZ2FtZXMnLCBnYW1lSWQudG9VcHBlckNhc2UoKSk7XG4gICAgICBjb25zdCBnYW1lRG9jID0gYXdhaXQgZ2V0RG9jKGdhbWVSZWYpO1xuICAgICAgXG4gICAgICBpZiAoIWdhbWVEb2MuZXhpc3RzKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHYW1lIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGdhbWVEYXRhID0gZ2FtZURvYy5kYXRhKCk7XG4gICAgICBjb25zdCBnYW1lU3RhdGUgPSBnYW1lRGF0YVsnX190cmVuZGd1ZXNzZXIuc3RhdGUnXSBhcyBUcmVuZEd1ZXNzZXJHYW1lU3RhdGU7XG4gICAgICBcbiAgICAgIGlmICghZ2FtZVN0YXRlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZ2FtZSBzdGF0ZSBmb3VuZCcpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBPbmx5IHVwZGF0ZSBpZiBnYW1lIHdhcyBhY3R1YWxseSBzdGFydGVkXG4gICAgICBpZiAoZ2FtZVN0YXRlLnN0YXJ0ZWQpIHtcbiAgICAgICAgLy8gTWFyayBnYW1lIGFzIGZpbmlzaGVkXG4gICAgICAgIGF3YWl0IHVwZGF0ZURvYyhnYW1lUmVmLCB7XG4gICAgICAgICAgc3RhdHVzOiAnZmluaXNoZWQnLFxuICAgICAgICAgICdfX3RyZW5kZ3Vlc3Nlci5zdGF0ZSc6IHtcbiAgICAgICAgICAgIC4uLmdhbWVTdGF0ZSxcbiAgICAgICAgICAgIGZpbmlzaGVkOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBoaWdoIHNjb3JlIGlmIG5lZWRlZFxuICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZUhpZ2hTY29yZShwbGF5ZXJVaWQsIGdhbWVTdGF0ZS5jYXRlZ29yeSwgZmluYWxTY29yZSk7XG4gICAgICB9XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZW5kaW5nIGdhbWU6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvLyBDcmVhdGUgYSBuZXcgZ2FtZSBzZXNzaW9uXG4gIHN0YXRpYyBhc3luYyBjcmVhdGVHYW1lKGNyZWF0ZWRCeTogc3RyaW5nLCBwbGF5ZXJOYW1lOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBHZW5lcmF0ZSBhIHNob3J0IDYtY2hhcmFjdGVyIGdhbWUgSUQgKHVwcGVyY2FzZSlcbiAgICAgIGNvbnN0IGdhbWVJZCA9IHRoaXMuZ2VuZXJhdGVHYW1lSWQoKTtcbiAgICAgIGNvbnN0IGdhbWVSZWYgPSBkb2MoZGIsICdnYW1lcycsIGdhbWVJZCk7XG4gICAgICBcbiAgICAgIC8vIEluaXRpYWxpemUgcGxheWVyIGRhdGFcbiAgICAgIGNvbnN0IHBsYXllckRhdGE6IFRyZW5kR3Vlc3NlclBsYXllciA9IHtcbiAgICAgICAgdWlkOiBjcmVhdGVkQnksXG4gICAgICAgIG5hbWU6IHBsYXllck5hbWUgfHwgJ1BsYXllcicsXG4gICAgICAgIHNjb3JlOiAwXG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBJbml0aWFsIGdhbWUgZGF0YVxuICAgICAgY29uc3QgZ2FtZURhdGEgPSB7XG4gICAgICAgIGlkOiBnYW1lSWQsXG4gICAgICAgIGNyZWF0ZWRBdDogc2VydmVyVGltZXN0YW1wKCksXG4gICAgICAgIGNyZWF0ZWRCeSxcbiAgICAgICAgZ2FtZVR5cGU6ICd0cmVuZGd1ZXNzZXInLFxuICAgICAgICBzdGF0dXM6ICd3YWl0aW5nJyxcbiAgICAgICAgW2NyZWF0ZWRCeV06IHBsYXllckRhdGFcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGF3YWl0IHNldERvYyhnYW1lUmVmLCBnYW1lRGF0YSk7XG4gICAgICByZXR1cm4gZ2FtZUlkO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIGdhbWU6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvLyBGZXRjaCBsZWFkZXJib2FyZCBmb3IgYSBjYXRlZ29yeVxuICBzdGF0aWMgYXN5bmMgZ2V0TGVhZGVyYm9hcmQoY2F0ZWdvcnk6IFNlYXJjaENhdGVnb3J5KTogUHJvbWlzZTxUcmVuZEd1ZXNzZXJQbGF5ZXJbXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBsZWFkZXJib2FyZFJlZiA9IGNvbGxlY3Rpb24oZGIsICdsZWFkZXJib2FyZCcpO1xuICAgICAgY29uc3QgcSA9IHF1ZXJ5KFxuICAgICAgICBsZWFkZXJib2FyZFJlZixcbiAgICAgICAgd2hlcmUoJ2NhdGVnb3J5JywgJz09JywgY2F0ZWdvcnkpLFxuICAgICAgICBvcmRlckJ5KCdzY29yZScsICdkZXNjJyksXG4gICAgICAgIGxpbWl0KDEwKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgY29uc3QgcXVlcnlTbmFwc2hvdCA9IGF3YWl0IGdldERvY3MocSk7XG4gICAgICBjb25zdCBsZWFkZXJib2FyZDogVHJlbmRHdWVzc2VyUGxheWVyW10gPSBbXTtcbiAgICAgIFxuICAgICAgcXVlcnlTbmFwc2hvdC5mb3JFYWNoKChkb2MpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGRvYy5kYXRhKCk7XG4gICAgICAgIGxlYWRlcmJvYXJkLnB1c2goe1xuICAgICAgICAgIHVpZDogZGF0YS51aWQsXG4gICAgICAgICAgbmFtZTogZGF0YS5uYW1lLFxuICAgICAgICAgIHNjb3JlOiBkYXRhLnNjb3JlLFxuICAgICAgICAgIGhpZ2hTY29yZXM6IGRhdGEuaGlnaFNjb3Jlc1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4gbGVhZGVyYm9hcmQ7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgbGVhZGVyYm9hcmQ6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvLyBIZWxwZXIgbWV0aG9kc1xuICBwcml2YXRlIHN0YXRpYyBhc3luYyB1cGRhdGVIaWdoU2NvcmUoXG4gICAgcGxheWVyVWlkOiBzdHJpbmcsIFxuICAgIGNhdGVnb3J5OiBTZWFyY2hDYXRlZ29yeSwgXG4gICAgc2NvcmU6IG51bWJlclxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGxheWVyUmVmID0gZG9jKGRiLCAncGxheWVycycsIHBsYXllclVpZCk7XG4gICAgICBjb25zdCBwbGF5ZXJEb2MgPSBhd2FpdCBnZXREb2MocGxheWVyUmVmKTtcbiAgICAgIFxuICAgICAgaWYgKHBsYXllckRvYy5leGlzdHMoKSkge1xuICAgICAgICBjb25zdCBwbGF5ZXJEYXRhID0gcGxheWVyRG9jLmRhdGEoKTtcbiAgICAgICAgY29uc3QgY3VycmVudEhpZ2hTY29yZSA9IHBsYXllckRhdGEuaGlnaFNjb3Jlcz8uW2NhdGVnb3J5XSB8fCAwO1xuICAgICAgICBcbiAgICAgICAgaWYgKHNjb3JlID4gY3VycmVudEhpZ2hTY29yZSkge1xuICAgICAgICAgIC8vIFVwZGF0ZSBwbGF5ZXIncyBoaWdoIHNjb3JlIGZvciB0aGlzIGNhdGVnb3J5XG4gICAgICAgICAgYXdhaXQgdXBkYXRlRG9jKHBsYXllclJlZiwge1xuICAgICAgICAgICAgW2BoaWdoU2NvcmVzLiR7Y2F0ZWdvcnl9YF06IHNjb3JlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQWxzbyB1cGRhdGUgbGVhZGVyYm9hcmQgaWYgc2NvcmUgaXMgc2lnbmlmaWNhbnRcbiAgICAgICAgICBpZiAoc2NvcmUgPiA1KSB7XG4gICAgICAgICAgICBjb25zdCBsZWFkZXJib2FyZFJlZiA9IGRvYyhkYiwgJ2xlYWRlcmJvYXJkJywgYCR7Y2F0ZWdvcnl9XyR7cGxheWVyVWlkfWApO1xuICAgICAgICAgICAgYXdhaXQgc2V0RG9jKGxlYWRlcmJvYXJkUmVmLCB7XG4gICAgICAgICAgICAgIHVpZDogcGxheWVyVWlkLFxuICAgICAgICAgICAgICBuYW1lOiBwbGF5ZXJEYXRhLm5hbWUgfHwgJ1Vua25vd24gUGxheWVyJyxcbiAgICAgICAgICAgICAgc2NvcmUsXG4gICAgICAgICAgICAgIGNhdGVnb3J5LFxuICAgICAgICAgICAgICB1cGRhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpXG4gICAgICAgICAgICB9LCB7IG1lcmdlOiB0cnVlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGhpZ2ggc2NvcmU6JywgZXJyb3IpO1xuICAgICAgLy8gRG9uJ3QgdGhyb3csIGp1c3QgbG9nIC0gdGhpcyBpcyBhIG5vbi1jcml0aWNhbCBvcGVyYXRpb25cbiAgICB9XG4gIH1cbiAgXG4gIHByaXZhdGUgc3RhdGljIGFzeW5jIGZldGNoVGVybXNCeUNhdGVnb3J5KGNhdGVnb3J5OiBTZWFyY2hDYXRlZ29yeSk6IFByb21pc2U8U2VhcmNoVGVybVtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRlcm1zUmVmID0gY29sbGVjdGlvbihkYiwgJ3NlYXJjaFRlcm1zJyk7XG4gICAgICBsZXQgcTtcbiAgICAgIFxuICAgICAgaWYgKGNhdGVnb3J5ID09PSAnZXZlcnl0aGluZycpIHtcbiAgICAgICAgLy8gRm9yIFwiZXZlcnl0aGluZ1wiIGNhdGVnb3J5LCBnZXQgYSBtaXggb2YgYWxsIGNhdGVnb3JpZXNcbiAgICAgICAgcSA9IHF1ZXJ5KHRlcm1zUmVmLCBsaW1pdCg1MCkpO1xuICAgICAgfSBlbHNlIGlmIChjYXRlZ29yeSA9PT0gJ2xhdGVzdCcpIHtcbiAgICAgICAgLy8gRm9yIFwibGF0ZXN0XCIsIGdldCB0aGUgbW9zdCByZWNlbnRseSBhZGRlZCB0ZXJtc1xuICAgICAgICBxID0gcXVlcnkodGVybXNSZWYsIG9yZGVyQnkoJ3RpbWVzdGFtcCcsICdkZXNjJyksIGxpbWl0KDUwKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igc3BlY2lmaWMgY2F0ZWdvcmllc1xuICAgICAgICBxID0gcXVlcnkodGVybXNSZWYsIHdoZXJlKCdjYXRlZ29yeScsICc9PScsIGNhdGVnb3J5KSwgbGltaXQoNTApKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgcXVlcnlTbmFwc2hvdCA9IGF3YWl0IGdldERvY3MocSk7XG4gICAgICBjb25zdCB0ZXJtczogU2VhcmNoVGVybVtdID0gW107XG4gICAgICBcbiAgICAgIHF1ZXJ5U25hcHNob3QuZm9yRWFjaCgoZG9jKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBkb2MuZGF0YSgpIGFzIFNlYXJjaFRlcm07XG4gICAgICAgIHRlcm1zLnB1c2goe1xuICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgaWQ6IGRvYy5pZFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4gdGVybXM7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgdGVybXM6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICBwcml2YXRlIHN0YXRpYyBhc3luYyBmZXRjaEN1c3RvbVRlcm1XaXRoUmVsYXRlZChjdXN0b21UZXJtOiBzdHJpbmcpOiBQcm9taXNlPFNlYXJjaFRlcm1bXT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBUaGlzIHdvdWxkIHR5cGljYWxseSBjYWxsIGEgRmlyZWJhc2UgRnVuY3Rpb24gdG8gZ2V0IHRoZSBjdXN0b20gdGVybSBkYXRhXG4gICAgICAvLyBGb3Igbm93LCB3ZSdsbCBzaW11bGF0ZSBpdCB3aXRoIGEgcGxhY2Vob2xkZXJcbiAgICAgIFxuICAgICAgLy8gRmlyc3QgdGVybSB3aWxsIGJlIHRoZSBjdXN0b20gb25lXG4gICAgICBjb25zdCBjdXN0b21TZWFyY2hUZXJtOiBTZWFyY2hUZXJtID0ge1xuICAgICAgICBpZDogdXVpZHY0KCksXG4gICAgICAgIHRlcm06IGN1c3RvbVRlcm0sXG4gICAgICAgIHZvbHVtZTogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwKSArIDEsIC8vIFBsYWNlaG9sZGVyIHZvbHVtZVxuICAgICAgICBjYXRlZ29yeTogJ2N1c3RvbScsXG4gICAgICAgIGltYWdlVXJsOiBgaHR0cHM6Ly9zb3VyY2UudW5zcGxhc2guY29tL2ZlYXR1cmVkLz8ke2VuY29kZVVSSUNvbXBvbmVudChjdXN0b21UZXJtKX1gLFxuICAgICAgICB0aW1lc3RhbXA6IFRpbWVzdGFtcC5ub3coKVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gVGhlbiBnZXQgc29tZSByZWxhdGVkIHRlcm1zIGZyb20gdGhlIGRhdGFiYXNlIChyYW5kb20gZm9yIG5vdylcbiAgICAgIGNvbnN0IHRlcm1zUmVmID0gY29sbGVjdGlvbihkYiwgJ3NlYXJjaFRlcm1zJyk7XG4gICAgICBjb25zdCBxID0gcXVlcnkodGVybXNSZWYsIGxpbWl0KDIwKSk7XG4gICAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhxKTtcbiAgICAgIFxuICAgICAgY29uc3QgdGVybXM6IFNlYXJjaFRlcm1bXSA9IFtjdXN0b21TZWFyY2hUZXJtXTtcbiAgICAgIFxuICAgICAgcXVlcnlTbmFwc2hvdC5mb3JFYWNoKChkb2MpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGRvYy5kYXRhKCkgYXMgU2VhcmNoVGVybTtcbiAgICAgICAgdGVybXMucHVzaCh7XG4gICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICBpZDogZG9jLmlkXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiB0ZXJtcztcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBjdXN0b20gdGVybTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIHByaXZhdGUgc3RhdGljIHNodWZmbGVUZXJtcyh0ZXJtczogU2VhcmNoVGVybVtdKTogU2VhcmNoVGVybVtdIHtcbiAgICBjb25zdCBzaHVmZmxlZCA9IFsuLi50ZXJtc107XG4gICAgZm9yIChsZXQgaSA9IHNodWZmbGVkLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaSArIDEpKTtcbiAgICAgIFtzaHVmZmxlZFtpXSwgc2h1ZmZsZWRbal1dID0gW3NodWZmbGVkW2pdLCBzaHVmZmxlZFtpXV07XG4gICAgfVxuICAgIHJldHVybiBzaHVmZmxlZDtcbiAgfVxuICBcbiAgcHJpdmF0ZSBzdGF0aWMgZ2VuZXJhdGVHYW1lSWQoKTogc3RyaW5nIHtcbiAgICAvLyBHZW5lcmF0ZSBhIDYtY2hhcmFjdGVyIGFscGhhbnVtZXJpYyBjb2RlICh1cHBlcmNhc2UpXG4gICAgY29uc3QgY2hhcnMgPSAnQUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaMjM0NTY3ODknOyAvLyBSZW1vdmVkIGNvbmZ1c2FibGUgY2hhcmFjdGVyc1xuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgcmVzdWx0ICs9IGNoYXJzLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFycy5sZW5ndGgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSJdLCJuYW1lcyI6WyJkb2MiLCJzZXREb2MiLCJ1cGRhdGVEb2MiLCJnZXREb2MiLCJjb2xsZWN0aW9uIiwicXVlcnkiLCJ3aGVyZSIsImdldERvY3MiLCJUaW1lc3RhbXAiLCJzZXJ2ZXJUaW1lc3RhbXAiLCJsaW1pdCIsIm9yZGVyQnkiLCJkYiIsInY0IiwidXVpZHY0IiwiVVNFX01PQ0tfREFUQSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19VU0VfTU9DS19EQVRBIiwiVHJlbmRHdWVzc2VyU2VydmljZSIsInN0YXJ0R2FtZSIsImdhbWVJZCIsImNhdGVnb3J5IiwiY3VzdG9tVGVybSIsImdhbWVSZWYiLCJ0b1VwcGVyQ2FzZSIsImdhbWVEb2MiLCJleGlzdHMiLCJFcnJvciIsInRlcm1zIiwiZmV0Y2hDdXN0b21UZXJtV2l0aFJlbGF0ZWQiLCJmZXRjaFRlcm1zQnlDYXRlZ29yeSIsImxlbmd0aCIsInNodWZmbGVkVGVybXMiLCJzaHVmZmxlVGVybXMiLCJnYW1lU3RhdGUiLCJjdXJyZW50Um91bmQiLCJrbm93blRlcm0iLCJoaWRkZW5UZXJtIiwic3RhcnRlZCIsImZpbmlzaGVkIiwidXNlZFRlcm1zIiwiaWQiLCJzbGljZSIsInVuZGVmaW5lZCIsInN0YXR1cyIsImVycm9yIiwiY29uc29sZSIsIm1ha2VHdWVzcyIsInBsYXllclVpZCIsImlzSGlnaGVyIiwiZ2FtZURhdGEiLCJkYXRhIiwicGxheWVyIiwiaXNDb3JyZWN0Iiwidm9sdW1lIiwibmV4dFJvdW5kIiwibmV3UGxheWVyU2NvcmUiLCJzY29yZSIsIm5leHRUZXJtIiwicmVtYWluaW5nVGVybXMiLCJ1cGRhdGVkU3RhdGUiLCJ3aW5uZXIiLCJ1cGRhdGVIaWdoU2NvcmUiLCJlbmRHYW1lIiwiZmluYWxTY29yZSIsImNyZWF0ZUdhbWUiLCJjcmVhdGVkQnkiLCJwbGF5ZXJOYW1lIiwiZ2VuZXJhdGVHYW1lSWQiLCJwbGF5ZXJEYXRhIiwidWlkIiwibmFtZSIsImNyZWF0ZWRBdCIsImdhbWVUeXBlIiwiZ2V0TGVhZGVyYm9hcmQiLCJsZWFkZXJib2FyZFJlZiIsInEiLCJxdWVyeVNuYXBzaG90IiwibGVhZGVyYm9hcmQiLCJmb3JFYWNoIiwicHVzaCIsImhpZ2hTY29yZXMiLCJwbGF5ZXJSZWYiLCJwbGF5ZXJEb2MiLCJjdXJyZW50SGlnaFNjb3JlIiwidXBkYXRlZEF0IiwibWVyZ2UiLCJ0ZXJtc1JlZiIsImN1c3RvbVNlYXJjaFRlcm0iLCJ0ZXJtIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwiaW1hZ2VVcmwiLCJlbmNvZGVVUklDb21wb25lbnQiLCJ0aW1lc3RhbXAiLCJub3ciLCJzaHVmZmxlZCIsImkiLCJqIiwiY2hhcnMiLCJyZXN1bHQiLCJjaGFyQXQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/lib/firebase/trendGuesserService.ts\n"));

/***/ })

});